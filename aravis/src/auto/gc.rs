// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use crate::{
	ffi, Buffer, Device, DomDocument, DomNode, GcFeatureNode, GcInvalidatorNode, GcNode,
	RegisterCachePolicy,
};
#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
use crate::{AccessCheckPolicy, RangeCheckPolicy};
use glib::{prelude::*, translate::*};

glib::wrapper! {
/// [`Gc`][crate::Gc] implements the root document for the storage of the Genicam feature
/// nodes. It builds the node tree by parsing an xml file in the Genicam
/// standard format. See http://www.genicam.org.
///
/// # Implements
///
/// [`DomDocumentExt`][trait@crate::prelude::DomDocumentExt], [`DomNodeExt`][trait@crate::prelude::DomNodeExt], [`trait@glib::ObjectExt`]
	#[doc(alias = "ArvGc")]
	pub struct Gc(Object<ffi::ArvGc, ffi::ArvGcClass>) @extends DomDocument, DomNode;

	match fn {
		type_ => || ffi::arv_gc_get_type(),
	}
}

impl Gc {
	//#[doc(alias = "arv_gc_new")]
	//pub fn new(device: &impl IsA<Device>, xml: /*Unimplemented*/Option<Basic: Pointer>, size: usize) -> Gc {
	//    unsafe { TODO: call ffi:arv_gc_new() }
	//}

	#[doc(alias = "arv_gc_p_value_indexed_node_new")]
	pub fn p_value_indexed_node_new() -> Gc {
		assert_initialized_main_thread!();
		unsafe { GcNode::from_glib_full(ffi::arv_gc_p_value_indexed_node_new()).unsafe_cast() }
	}

	#[cfg(feature = "v0_8_6")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_get_access_check_policy")]
	#[doc(alias = "get_access_check_policy")]
	pub fn access_check_policy(&self) -> AccessCheckPolicy {
		unsafe { from_glib(ffi::arv_gc_get_access_check_policy(self.to_glib_none().0)) }
	}

/// Retrieves the binded buffer.
///
/// # Returns
///
/// a [`Buffer`][crate::Buffer].
	#[doc(alias = "arv_gc_get_buffer")]
	#[doc(alias = "get_buffer")]
	pub fn buffer(&self) -> Option<Buffer> {
		unsafe { from_glib_none(ffi::arv_gc_get_buffer(self.to_glib_none().0)) }
	}

/// Retrieves the device handled by this genicam interface. The device is used for register access.
///
/// # Returns
///
/// a [`Device`][crate::Device].
	#[doc(alias = "arv_gc_get_device")]
	#[doc(alias = "get_device")]
	pub fn device(&self) -> Option<Device> {
		unsafe { from_glib_none(ffi::arv_gc_get_device(self.to_glib_none().0)) }
	}

/// Retrieves a genicam node by name.
/// ## `name`
/// node name
///
/// # Returns
///
/// a [`GcNode`][crate::GcNode], null if not found.
	#[doc(alias = "arv_gc_get_node")]
	#[doc(alias = "get_node")]
	pub fn node(&self, name: &str) -> Option<GcNode> {
		unsafe {
			from_glib_none(ffi::arv_gc_get_node(
				self.to_glib_none().0,
				name.to_glib_none().0,
			))
		}
	}

	#[cfg(feature = "v0_8_6")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_get_range_check_policy")]
	#[doc(alias = "get_range_check_policy")]
	pub fn range_check_policy(&self) -> RangeCheckPolicy {
		unsafe { from_glib(ffi::arv_gc_get_range_check_policy(self.to_glib_none().0)) }
	}

	#[doc(alias = "arv_gc_get_register_cache_policy")]
	#[doc(alias = "get_register_cache_policy")]
	pub fn register_cache_policy(&self) -> RegisterCachePolicy {
		unsafe { from_glib(ffi::arv_gc_get_register_cache_policy(self.to_glib_none().0)) }
	}

	#[doc(alias = "arv_gc_register_feature_node")]
	pub fn register_feature_node(&self, node: &impl IsA<GcFeatureNode>) {
		unsafe {
			ffi::arv_gc_register_feature_node(
				self.to_glib_none().0,
				node.as_ref().to_glib_none().0,
			);
		}
	}

	#[cfg(feature = "v0_8_6")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_set_access_check_policy")]
	pub fn set_access_check_policy(&self, policy: AccessCheckPolicy) {
		unsafe {
			ffi::arv_gc_set_access_check_policy(self.to_glib_none().0, policy.into_glib());
		}
	}

	#[doc(alias = "arv_gc_set_buffer")]
	pub fn set_buffer(&self, buffer: &Buffer) {
		unsafe {
			ffi::arv_gc_set_buffer(self.to_glib_none().0, buffer.to_glib_none().0);
		}
	}

	//#[doc(alias = "arv_gc_set_default_node_data")]
	//pub fn set_default_node_data(&self, node_name: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) {
	//    unsafe { TODO: call ffi:arv_gc_set_default_node_data() }
	//}

	#[cfg(feature = "v0_8_6")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_gc_set_range_check_policy")]
	pub fn set_range_check_policy(&self, policy: RangeCheckPolicy) {
		unsafe {
			ffi::arv_gc_set_range_check_policy(self.to_glib_none().0, policy.into_glib());
		}
	}

	#[doc(alias = "arv_gc_set_register_cache_policy")]
	pub fn set_register_cache_policy(&self, policy: RegisterCachePolicy) {
		unsafe {
			ffi::arv_gc_set_register_cache_policy(self.to_glib_none().0, policy.into_glib());
		}
	}

	#[doc(alias = "arv_gc_invalidator_has_changed")]
	pub fn invalidator_has_changed(self_: &GcInvalidatorNode) -> bool {
		skip_assert_initialized!();
		unsafe { from_glib(ffi::arv_gc_invalidator_has_changed(self_.to_glib_none().0)) }
	}
}

unsafe impl Send for Gc {}
