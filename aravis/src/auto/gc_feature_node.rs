// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use crate::{ffi, DomElement, DomNode, GcAccessMode, GcNameSpace, GcNode, GcVisibility};
use glib::{prelude::*, translate::*};

glib::wrapper! {
/// [`GcFeatureNode`][crate::GcFeatureNode] provides a base class for the implementation of the different
/// types of Genicam feature node (Group, Integer, Float, Enumeration...).
///
/// This is an Abstract Base Class, you cannot instantiate it.
///
/// # Implements
///
/// [`GcFeatureNodeExt`][trait@crate::prelude::GcFeatureNodeExt], [`GcNodeExt`][trait@crate::prelude::GcNodeExt], [`DomElementExt`][trait@crate::prelude::DomElementExt], [`DomNodeExt`][trait@crate::prelude::DomNodeExt], [`trait@glib::ObjectExt`]
	#[doc(alias = "ArvGcFeatureNode")]
	pub struct GcFeatureNode(Object<ffi::ArvGcFeatureNode, ffi::ArvGcFeatureNodeClass>) @extends GcNode, DomElement, DomNode;

	match fn {
		type_ => || ffi::arv_gc_feature_node_get_type(),
	}
}

impl GcFeatureNode {
	pub const NONE: Option<&'static GcFeatureNode> = None;
}

unsafe impl Send for GcFeatureNode {}

mod sealed {
	pub trait Sealed {}
	impl<T: super::IsA<super::GcFeatureNode>> Sealed for T {}
}

/// Trait containing all [`struct@GcFeatureNode`] methods.
///
/// # Implementors
///
/// [`GcBoolean`][struct@crate::GcBoolean], [`GcCategory`][struct@crate::GcCategory], [`GcCommand`][struct@crate::GcCommand], [`GcConverter`][struct@crate::GcConverter], [`GcEnumEntry`][struct@crate::GcEnumEntry], [`GcEnumeration`][struct@crate::GcEnumeration], [`GcFeatureNode`][struct@crate::GcFeatureNode], [`GcFloatNode`][struct@crate::GcFloatNode], [`GcGroupNode`][struct@crate::GcGroupNode], [`GcIntegerNode`][struct@crate::GcIntegerNode], [`GcPort`][struct@crate::GcPort], [`GcRegisterDescriptionNode`][struct@crate::GcRegisterDescriptionNode], [`GcRegisterNode`][struct@crate::GcRegisterNode], [`GcStringNode`][struct@crate::GcStringNode], [`GcStructEntryNode`][struct@crate::GcStructEntryNode], [`GcSwissKnife`][struct@crate::GcSwissKnife]
pub trait GcFeatureNodeExt: IsA<GcFeatureNode> + sealed::Sealed + 'static {
	#[doc(alias = "arv_gc_feature_node_get_actual_access_mode")]
	#[doc(alias = "get_actual_access_mode")]
	fn actual_access_mode(&self) -> GcAccessMode {
		unsafe {
			from_glib(ffi::arv_gc_feature_node_get_actual_access_mode(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_description")]
	#[doc(alias = "get_description")]
	fn description(&self) -> Option<glib::GString> {
		unsafe {
			from_glib_none(ffi::arv_gc_feature_node_get_description(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_display_name")]
	#[doc(alias = "get_display_name")]
	fn display_name(&self) -> Option<glib::GString> {
		unsafe {
			from_glib_none(ffi::arv_gc_feature_node_get_display_name(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_imposed_access_mode")]
	#[doc(alias = "get_imposed_access_mode")]
	fn imposed_access_mode(&self) -> GcAccessMode {
		unsafe {
			from_glib(ffi::arv_gc_feature_node_get_imposed_access_mode(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_name")]
	#[doc(alias = "get_name")]
	fn name(&self) -> Option<glib::GString> {
		unsafe {
			from_glib_none(ffi::arv_gc_feature_node_get_name(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_name_space")]
	#[doc(alias = "get_name_space")]
	fn name_space(&self) -> GcNameSpace {
		unsafe {
			from_glib(ffi::arv_gc_feature_node_get_name_space(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_tooltip")]
	#[doc(alias = "get_tooltip")]
	fn tooltip(&self) -> Option<glib::GString> {
		unsafe {
			from_glib_none(ffi::arv_gc_feature_node_get_tooltip(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_value_as_string")]
	#[doc(alias = "get_value_as_string")]
	fn value_as_string(&self) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_gc_feature_node_get_value_as_string(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_gc_feature_node_get_visibility")]
	#[doc(alias = "get_visibility")]
	fn visibility(&self) -> GcVisibility {
		unsafe {
			from_glib(ffi::arv_gc_feature_node_get_visibility(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_gc_feature_node_is_available")]
	fn is_available(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_gc_feature_node_is_available(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_gc_feature_node_is_implemented")]
	fn is_implemented(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_gc_feature_node_is_implemented(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_gc_feature_node_is_locked")]
	fn is_locked(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_gc_feature_node_is_locked(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_gc_feature_node_set_value_from_string")]
	fn set_value_from_string(&self, string: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_gc_feature_node_set_value_from_string(
				self.as_ref().to_glib_none().0,
				string.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}
}

impl<O: IsA<GcFeatureNode>> GcFeatureNodeExt for O {}
