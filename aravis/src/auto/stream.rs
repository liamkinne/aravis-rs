// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use crate::{ffi, Buffer, Device};
use glib::{
	prelude::*,
	signal::{connect_raw, SignalHandlerId},
	translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
/// [`Stream`][crate::Stream] provides an abstract base class for the implementation of video
/// stream reception threads. The interface between the reception thread and the
/// main thread is done using asynchronous queues, containing [`Buffer`][crate::Buffer]
/// objects.
///
/// This is an Abstract Base Class, you cannot instantiate it.
///
/// ## Properties
///
///
/// #### `callback`
///  Readable | Writeable | Construct Only
///
///
/// #### `callback-data`
///  Readable | Writeable | Construct Only
///
///
/// #### `destroy-notify`
///  Readable | Writeable | Construct Only
///
///
/// #### `device`
///  Readable | Writeable | Construct Only
///
///
/// #### `emit-signals`
///  Readable | Writeable
///
/// ## Signals
///
///
/// #### `new-buffer`
///  Signal that a new buffer is available.
///
/// This signal is emited from the stream receive thread and only when the
/// "emit-signals" property is [`true`].
///
/// The new buffer can be retrieved with [`StreamExt::pop_buffer()`][crate::prelude::StreamExt::pop_buffer()].
///
/// Note that this signal is only emited when the "emit-signals" property is
/// set to [`true`], which it is not by default for performance reasons.
///
///
///
/// # Implements
///
/// [`StreamExt`][trait@crate::prelude::StreamExt], [`trait@glib::ObjectExt`]
	#[doc(alias = "ArvStream")]
	pub struct Stream(Object<ffi::ArvStream, ffi::ArvStreamClass>);

	match fn {
		type_ => || ffi::arv_stream_get_type(),
	}
}

impl Stream {
	pub const NONE: Option<&'static Stream> = None;
}

unsafe impl Send for Stream {}

mod sealed {
	pub trait Sealed {}
	impl<T: super::IsA<super::Stream>> Sealed for T {}
}

/// Trait containing all [`struct@Stream`] methods.
///
/// # Implementors
///
/// [`FakeStream`][struct@crate::FakeStream], [`GvStream`][struct@crate::GvStream], [`Stream`][struct@crate::Stream], [`UvStream`][struct@crate::UvStream]
pub trait StreamExt: IsA<Stream> + sealed::Sealed + 'static {
	#[doc(alias = "arv_stream_get_emit_signals")]
	#[doc(alias = "get_emit_signals")]
	#[doc(alias = "emit-signals")]
	fn emits_signals(&self) -> bool {
		unsafe {
			from_glib(ffi::arv_stream_get_emit_signals(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[cfg(feature = "v0_8_11")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
	#[doc(alias = "arv_stream_get_info_double")]
	#[doc(alias = "get_info_double")]
	fn info_double(&self, id: u32) -> f64 {
		unsafe { ffi::arv_stream_get_info_double(self.as_ref().to_glib_none().0, id) }
	}

	#[cfg(feature = "v0_8_11")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
	#[doc(alias = "arv_stream_get_info_double_by_name")]
	#[doc(alias = "get_info_double_by_name")]
	fn info_double_by_name(&self, name: &str) -> f64 {
		unsafe {
			ffi::arv_stream_get_info_double_by_name(
				self.as_ref().to_glib_none().0,
				name.to_glib_none().0,
			)
		}
	}

	#[cfg(feature = "v0_8_11")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
	#[doc(alias = "arv_stream_get_info_name")]
	#[doc(alias = "get_info_name")]
	fn info_name(&self, id: u32) -> Option<glib::GString> {
		unsafe {
			from_glib_none(ffi::arv_stream_get_info_name(
				self.as_ref().to_glib_none().0,
				id,
			))
		}
	}

	#[cfg(feature = "v0_8_11")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
	#[doc(alias = "arv_stream_get_info_type")]
	#[doc(alias = "get_info_type")]
	fn info_type(&self, id: u32) -> glib::types::Type {
		unsafe {
			from_glib(ffi::arv_stream_get_info_type(
				self.as_ref().to_glib_none().0,
				id,
			))
		}
	}

	#[cfg(feature = "v0_8_11")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
	#[doc(alias = "arv_stream_get_info_uint64")]
	#[doc(alias = "get_info_uint64")]
	fn info_uint64(&self, id: u32) -> u64 {
		unsafe { ffi::arv_stream_get_info_uint64(self.as_ref().to_glib_none().0, id) }
	}

	#[cfg(feature = "v0_8_11")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
	#[doc(alias = "arv_stream_get_info_uint64_by_name")]
	#[doc(alias = "get_info_uint64_by_name")]
	fn info_uint64_by_name(&self, name: &str) -> u64 {
		unsafe {
			ffi::arv_stream_get_info_uint64_by_name(
				self.as_ref().to_glib_none().0,
				name.to_glib_none().0,
			)
		}
	}

	#[doc(alias = "arv_stream_get_n_buffers")]
	#[doc(alias = "get_n_buffers")]
	fn n_buffers(&self) -> (i32, i32) {
		unsafe {
			let mut n_input_buffers = std::mem::MaybeUninit::uninit();
			let mut n_output_buffers = std::mem::MaybeUninit::uninit();
			ffi::arv_stream_get_n_buffers(
				self.as_ref().to_glib_none().0,
				n_input_buffers.as_mut_ptr(),
				n_output_buffers.as_mut_ptr(),
			);
			(
				n_input_buffers.assume_init(),
				n_output_buffers.assume_init(),
			)
		}
	}

	#[cfg(feature = "v0_8_11")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
	#[doc(alias = "arv_stream_get_n_infos")]
	#[doc(alias = "get_n_infos")]
	fn n_infos(&self) -> u32 {
		unsafe { ffi::arv_stream_get_n_infos(self.as_ref().to_glib_none().0) }
	}

	#[doc(alias = "arv_stream_get_statistics")]
	#[doc(alias = "get_statistics")]
	fn statistics(&self) -> (u64, u64, u64) {
		unsafe {
			let mut n_completed_buffers = std::mem::MaybeUninit::uninit();
			let mut n_failures = std::mem::MaybeUninit::uninit();
			let mut n_underruns = std::mem::MaybeUninit::uninit();
			ffi::arv_stream_get_statistics(
				self.as_ref().to_glib_none().0,
				n_completed_buffers.as_mut_ptr(),
				n_failures.as_mut_ptr(),
				n_underruns.as_mut_ptr(),
			);
			(
				n_completed_buffers.assume_init(),
				n_failures.assume_init(),
				n_underruns.assume_init(),
			)
		}
	}

	#[doc(alias = "arv_stream_pop_buffer")]
	fn pop_buffer(&self) -> Option<Buffer> {
		unsafe { from_glib_full(ffi::arv_stream_pop_buffer(self.as_ref().to_glib_none().0)) }
	}

	#[doc(alias = "arv_stream_push_buffer")]
	fn push_buffer(&self, buffer: Buffer) {
		unsafe {
			ffi::arv_stream_push_buffer(self.as_ref().to_glib_none().0, buffer.into_glib_ptr());
		}
	}

	#[doc(alias = "arv_stream_set_emit_signals")]
	#[doc(alias = "emit-signals")]
	fn set_emit_signals(&self, emit_signals: bool) {
		unsafe {
			ffi::arv_stream_set_emit_signals(
				self.as_ref().to_glib_none().0,
				emit_signals.into_glib(),
			);
		}
	}

	#[doc(alias = "arv_stream_start_thread")]
	fn start_thread(&self) {
		unsafe {
			ffi::arv_stream_start_thread(self.as_ref().to_glib_none().0);
		}
	}

	#[doc(alias = "arv_stream_stop_thread")]
	fn stop_thread(&self, delete_buffers: bool) -> u32 {
		unsafe {
			ffi::arv_stream_stop_thread(self.as_ref().to_glib_none().0, delete_buffers.into_glib())
		}
	}

	#[doc(alias = "arv_stream_timeout_pop_buffer")]
	fn timeout_pop_buffer(&self, timeout: u64) -> Option<Buffer> {
		unsafe {
			from_glib_full(ffi::arv_stream_timeout_pop_buffer(
				self.as_ref().to_glib_none().0,
				timeout,
			))
		}
	}

	#[doc(alias = "arv_stream_try_pop_buffer")]
	fn try_pop_buffer(&self) -> Option<Buffer> {
		unsafe {
			from_glib_full(ffi::arv_stream_try_pop_buffer(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	//fn callback(&self) -> /*Unimplemented*/Basic: Pointer {
	//    ObjectExt::property(self.as_ref(), "callback")
	//}

	//#[doc(alias = "callback-data")]
	//fn callback_data(&self) -> /*Unimplemented*/Basic: Pointer {
	//    ObjectExt::property(self.as_ref(), "callback-data")
	//}

	//#[doc(alias = "destroy-notify")]
	//fn destroy_notify(&self) -> /*Unimplemented*/Basic: Pointer {
	//    ObjectExt::property(self.as_ref(), "destroy-notify")
	//}

	fn device(&self) -> Option<Device> {
		ObjectExt::property(self.as_ref(), "device")
	}

	#[doc(alias = "new-buffer")]
	fn connect_new_buffer<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
		unsafe extern "C" fn new_buffer_trampoline<P: IsA<Stream>, F: Fn(&P) + Send + 'static>(
			this: *mut ffi::ArvStream,
			f: glib::ffi::gpointer,
		) {
			let f: &F = &*(f as *const F);
			f(Stream::from_glib_borrow(this).unsafe_cast_ref())
		}
		unsafe {
			let f: Box_<F> = Box_::new(f);
			connect_raw(
				self.as_ptr() as *mut _,
				b"new-buffer\0".as_ptr() as *const _,
				Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
					new_buffer_trampoline::<Self, F> as *const (),
				)),
				Box_::into_raw(f),
			)
		}
	}

	#[doc(alias = "emit-signals")]
	fn connect_emit_signals_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
		unsafe extern "C" fn notify_emit_signals_trampoline<
			P: IsA<Stream>,
			F: Fn(&P) + Send + 'static,
		>(
			this: *mut ffi::ArvStream,
			_param_spec: glib::ffi::gpointer,
			f: glib::ffi::gpointer,
		) {
			let f: &F = &*(f as *const F);
			f(Stream::from_glib_borrow(this).unsafe_cast_ref())
		}
		unsafe {
			let f: Box_<F> = Box_::new(f);
			connect_raw(
				self.as_ptr() as *mut _,
				b"notify::emit-signals\0".as_ptr() as *const _,
				Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
					notify_emit_signals_trampoline::<Self, F> as *const (),
				)),
				Box_::into_raw(f),
			)
		}
	}
}

impl<O: IsA<Stream>> StreamExt for O {}
