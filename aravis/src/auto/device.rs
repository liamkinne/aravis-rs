// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

#[cfg(feature = "v0_8_31")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
use crate::GcRepresentation;
#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
use crate::RangeCheckPolicy;
use crate::{ffi, ChunkParser, Gc, GcNode, RegisterCachePolicy};
#[cfg(feature = "v0_8_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
use crate::{AccessCheckPolicy, GcAccessMode};
#[cfg(feature = "v0_8_23")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
use crate::{Buffer, Stream, StreamCallbackType};
use glib::{
	prelude::*,
	signal::{connect_raw, SignalHandlerId},
	translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
/// [`Device`][crate::Device] is an abstract base class for the control of cameras. It provides
/// an easy access to the camera settings, and to its genicam interface for more
/// advanced uses.
///
/// This is an Abstract Base Class, you cannot instantiate it.
///
/// ## Signals
///
///
/// #### `control-lost`
///  Signal that the control of the device is lost.
///
/// This signal may be emited from a thread different than the main one,
/// so please take care to shared data access from the callback.
///
///
///
/// # Implements
///
/// [`DeviceExt`][trait@crate::prelude::DeviceExt], [`trait@glib::ObjectExt`]
	#[doc(alias = "ArvDevice")]
	pub struct Device(Object<ffi::ArvDevice, ffi::ArvDeviceClass>);

	match fn {
		type_ => || ffi::arv_device_get_type(),
	}
}

impl Device {
	pub const NONE: Option<&'static Device> = None;
}

unsafe impl Send for Device {}

mod sealed {
	pub trait Sealed {}
	impl<T: super::IsA<super::Device>> Sealed for T {}
}

/// Trait containing all [`struct@Device`] methods.
///
/// # Implementors
///
/// [`Device`][struct@crate::Device], [`FakeDevice`][struct@crate::FakeDevice], [`GvDevice`][struct@crate::GvDevice], [`UvDevice`][struct@crate::UvDevice]
pub trait DeviceExt: IsA<Device> + sealed::Sealed + 'static {
	#[doc(alias = "arv_device_create_chunk_parser")]
	fn create_chunk_parser(&self) -> Option<ChunkParser> {
		unsafe {
			from_glib_full(ffi::arv_device_create_chunk_parser(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_device_create_stream_full")]
	fn create_stream_full<P: Fn(&StreamCallbackType) + Send + 'static>(
		&self,
		callback: P,
	) -> Result<Stream, glib::Error> {
		let callback_data: Box_<P> = Box_::new(callback);
		unsafe extern "C" fn callback_func<P: Fn(&StreamCallbackType) + Send + 'static>(
			user_data: glib::ffi::gpointer,
			type_: ffi::ArvStreamCallbackType,
			buffer: *mut ffi::ArvBuffer,
		) {
			let type_ = from_glib_borrow(type_);
			let buffer = from_glib_borrow(buffer);
			let callback = &*(buffer as *mut P);
			(*callback)(&type_, &buffer)
		}
		let callback = Some(callback_func::<P> as _);
		unsafe extern "C" fn destroy_func<P: Fn(&StreamCallbackType) + Send + 'static>(
			data: glib::ffi::gpointer,
		) {
			let _callback = Box_::from_raw(data as *mut P);
		}
		let destroy_call3 = Some(destroy_func::<P> as _);
		let super_callback0: Box_<P> = callback_data;
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_create_stream_full(
				self.as_ref().to_glib_none().0,
				callback,
				Box_::into_raw(super_callback0) as *mut _,
				destroy_call3,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib_full(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_dup_available_enumeration_feature_values")]
	fn dup_available_enumeration_feature_values(
		&self,
		feature: &str,
	) -> Result<Vec<i64>, glib::Error> {
		unsafe {
			let mut n_values = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_dup_available_enumeration_feature_values(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				n_values.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_values.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_dup_available_enumeration_feature_values_as_display_names")]
	fn dup_available_enumeration_feature_values_as_display_names(
		&self,
		feature: &str,
	) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_values = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_dup_available_enumeration_feature_values_as_display_names(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				n_values.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_values.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_dup_available_enumeration_feature_values_as_strings")]
	fn dup_available_enumeration_feature_values_as_strings(
		&self,
		feature: &str,
	) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_values = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_dup_available_enumeration_feature_values_as_strings(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				n_values.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_values.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	//#[cfg(feature = "v0_8_31")]
	//#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	//#[doc(alias = "arv_device_dup_register_feature_value")]
	//fn dup_register_feature_value(&self, feature: &str) -> Result<(/*Unimplemented*/Option<Basic: Pointer>, u64), glib::Error> {
	//    unsafe { TODO: call ffi:arv_device_dup_register_feature_value() }
	//}

	#[doc(alias = "arv_device_execute_command")]
	fn execute_command(&self, feature: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_device_execute_command(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_get_boolean_feature_value")]
	#[doc(alias = "get_boolean_feature_value")]
	fn boolean_feature_value(&self, feature: &str) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_get_boolean_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_get_feature")]
	#[doc(alias = "get_feature")]
	fn feature(&self, feature: &str) -> Option<GcNode> {
		unsafe {
			from_glib_none(ffi::arv_device_get_feature(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
			))
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_device_get_feature_access_mode")]
	#[doc(alias = "get_feature_access_mode")]
	fn feature_access_mode(&self, feature: &str) -> GcAccessMode {
		unsafe {
			from_glib(ffi::arv_device_get_feature_access_mode(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
			))
		}
	}

	#[cfg(feature = "v0_8_31")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	#[doc(alias = "arv_device_get_feature_representation")]
	#[doc(alias = "get_feature_representation")]
	fn feature_representation(&self, feature: &str) -> GcRepresentation {
		unsafe {
			from_glib(ffi::arv_device_get_feature_representation(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_device_get_float_feature_bounds")]
	#[doc(alias = "get_float_feature_bounds")]
	fn float_feature_bounds(&self, feature: &str) -> Result<(f64, f64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_device_get_float_feature_bounds(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_16")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_16")))]
	#[doc(alias = "arv_device_get_float_feature_increment")]
	#[doc(alias = "get_float_feature_increment")]
	fn float_feature_increment(&self, feature: &str) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_get_float_feature_increment(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_get_float_feature_value")]
	#[doc(alias = "get_float_feature_value")]
	fn float_feature_value(&self, feature: &str) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_get_float_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_get_genicam")]
	#[doc(alias = "get_genicam")]
	fn genicam(&self) -> Option<Gc> {
		unsafe { from_glib_none(ffi::arv_device_get_genicam(self.as_ref().to_glib_none().0)) }
	}

	#[doc(alias = "arv_device_get_genicam_xml")]
	#[doc(alias = "get_genicam_xml")]
	fn genicam_xml(&self) -> (glib::GString, usize) {
		unsafe {
			let mut size = std::mem::MaybeUninit::uninit();
			let ret = from_glib_none(ffi::arv_device_get_genicam_xml(
				self.as_ref().to_glib_none().0,
				size.as_mut_ptr(),
			));
			(ret, size.assume_init())
		}
	}

	#[doc(alias = "arv_device_get_integer_feature_bounds")]
	#[doc(alias = "get_integer_feature_bounds")]
	fn integer_feature_bounds(&self, feature: &str) -> Result<(i64, i64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_device_get_integer_feature_bounds(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_get_integer_feature_increment")]
	#[doc(alias = "get_integer_feature_increment")]
	fn integer_feature_increment(&self, feature: &str) -> Result<i64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_get_integer_feature_increment(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_get_integer_feature_value")]
	#[doc(alias = "get_integer_feature_value")]
	fn integer_feature_value(&self, feature: &str) -> Result<i64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_get_integer_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_get_string_feature_value")]
	#[doc(alias = "get_string_feature_value")]
	fn string_feature_value(&self, feature: &str) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_get_string_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_17")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_17")))]
	#[doc(alias = "arv_device_is_enumeration_entry_available")]
	fn is_enumeration_entry_available(
		&self,
		feature: &str,
		entry: &str,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_device_is_enumeration_entry_available(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				entry.to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_is_feature_available")]
	fn is_feature_available(&self, feature: &str) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_is_feature_available(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_device_is_feature_implemented")]
	fn is_feature_implemented(&self, feature: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_device_is_feature_implemented(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	//#[doc(alias = "arv_device_read_memory")]
	//fn read_memory(&self, address: u64, size: u32, buffer: /*Unimplemented*/Option<Basic: Pointer>) -> Result<bool, glib::Error> {
	//    unsafe { TODO: call ffi:arv_device_read_memory() }
	//}

	#[doc(alias = "arv_device_read_register")]
	fn read_register(&self, address: u64) -> Result<(bool, u32), glib::Error> {
		unsafe {
			let mut value = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_read_register(
				self.as_ref().to_glib_none().0,
				address,
				value.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((from_glib(ret), value.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_device_set_access_check_policy")]
	fn set_access_check_policy(&self, policy: AccessCheckPolicy) {
		unsafe {
			ffi::arv_device_set_access_check_policy(
				self.as_ref().to_glib_none().0,
				policy.into_glib(),
			);
		}
	}

	#[doc(alias = "arv_device_set_boolean_feature_value")]
	fn set_boolean_feature_value(&self, feature: &str, value: bool) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_device_set_boolean_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_set_features_from_string")]
	fn set_features_from_string(&self, string: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_device_set_features_from_string(
				self.as_ref().to_glib_none().0,
				string.to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_set_float_feature_value")]
	fn set_float_feature_value(&self, feature: &str, value: f64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_device_set_float_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_device_set_integer_feature_value")]
	fn set_integer_feature_value(&self, feature: &str, value: i64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_device_set_integer_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_6")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_device_set_range_check_policy")]
	fn set_range_check_policy(&self, policy: RangeCheckPolicy) {
		unsafe {
			ffi::arv_device_set_range_check_policy(
				self.as_ref().to_glib_none().0,
				policy.into_glib(),
			);
		}
	}

	#[doc(alias = "arv_device_set_register_cache_policy")]
	fn set_register_cache_policy(&self, policy: RegisterCachePolicy) {
		unsafe {
			ffi::arv_device_set_register_cache_policy(
				self.as_ref().to_glib_none().0,
				policy.into_glib(),
			);
		}
	}

	//#[doc(alias = "arv_device_set_register_feature_value")]
	//fn set_register_feature_value(&self, feature: &str, value: /*Unimplemented*/Option<Basic: Pointer>) -> Result<(), glib::Error> {
	//    unsafe { TODO: call ffi:arv_device_set_register_feature_value() }
	//}

	#[doc(alias = "arv_device_set_string_feature_value")]
	fn set_string_feature_value(&self, feature: &str, value: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_device_set_string_feature_value(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	//#[doc(alias = "arv_device_write_memory")]
	//fn write_memory(&self, address: u64, size: u32, buffer: /*Unimplemented*/Option<Basic: Pointer>) -> Result<bool, glib::Error> {
	//    unsafe { TODO: call ffi:arv_device_write_memory() }
	//}

	#[doc(alias = "arv_device_write_register")]
	fn write_register(&self, address: u64, value: u32) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_device_write_register(
				self.as_ref().to_glib_none().0,
				address,
				value,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "control-lost")]
	fn connect_control_lost<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
		unsafe extern "C" fn control_lost_trampoline<P: IsA<Device>, F: Fn(&P) + Send + 'static>(
			this: *mut ffi::ArvDevice,
			f: glib::ffi::gpointer,
		) {
			let f: &F = &*(f as *const F);
			f(Device::from_glib_borrow(this).unsafe_cast_ref())
		}
		unsafe {
			let f: Box_<F> = Box_::new(f);
			connect_raw(
				self.as_ptr() as *mut _,
				b"control-lost\0".as_ptr() as *const _,
				Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
					control_lost_trampoline::<Self, F> as *const (),
				)),
				Box_::into_raw(f),
			)
		}
	}
}

impl<O: IsA<Device>> DeviceExt for O {}
