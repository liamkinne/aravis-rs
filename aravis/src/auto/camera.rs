// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

#[cfg(feature = "v0_8_25")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_25")))]
use crate::ComponentSelectionFlags;
#[cfg(feature = "v0_8_31")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
use crate::GcRepresentation;
#[cfg(feature = "v0_8_3")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_3")))]
use crate::GvPacketSizeAdjustment;
#[cfg(feature = "v0_8_17")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_17")))]
use crate::UvUsbMode;
use crate::{
	ffi, AcquisitionMode, Auto, Buffer, ChunkParser, Device, ExposureMode, GvStreamOption,
	PixelFormat,
};
#[cfg(feature = "v0_8_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
use crate::{AccessCheckPolicy, GvIpConfigurationMode};
#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
use crate::{RangeCheckPolicy, RegisterCachePolicy};
use glib::{prelude::*, translate::*};

glib::wrapper! {
/// [class`Aravis`] is a class for the generic control of cameras. It hides the complexity of the genicam interface
/// by providing a simple API, with the drawback of not exposing all the available features. See [class`Aravis`]
/// and [class`Aravis`] for a more advanced use of the Aravis library.
///
/// ## Properties
///
///
/// #### `device`
///  Internal device object
///
/// Readable | Writeable | Construct Only
///
///
/// #### `name`
///  Internal device name for object construction
///
/// Writeable | Construct Only
///
/// # Implements
///
/// [`CameraExt`][trait@crate::prelude::CameraExt], [`trait@glib::ObjectExt`]
	#[doc(alias = "ArvCamera")]
	pub struct Camera(Object<ffi::ArvCamera, ffi::ArvCameraClass>);

	match fn {
		type_ => || ffi::arv_camera_get_type(),
	}
}

impl Camera {
	pub const NONE: Option<&'static Camera> = None;

	/// Creates a new [`Camera`][crate::Camera]. If `name` is null, it will instantiate the
	/// first available camera.
	///
	/// If the camera is a GigEVision, `name` can be either:
	///
	/// - &lt;vendor&gt;-&lt;model&gt;-&lt;serial&gt;
	/// - &lt;vendor_alias&gt;-&lt;serial&gt;
	/// - &lt;vendor&gt;-&lt;serial&gt;
	/// - &lt;user_id&gt;
	/// - &lt;ip_address&gt;
	/// - &lt;mac_address&gt;
	///
	/// For example:
	///
	/// - The Imaging Source Europe GmbH-DFK 33GX265-39020369
	/// - The Imaging Source Europe GmbH-39020369
	/// - TIS-39020369
	/// - 192.168.0.2
	/// - 00:07:48:af:a2:61
	///
	/// If the camera is a USB3Vision device, `name` is either:
	///
	/// - &lt;vendor_alias&gt;-&lt;serial&gt;
	/// - &lt;vendor&gt;-&lt;serial&gt;
	/// ## `name`
	/// name of the camera.
	///
	/// # Returns
	///
	/// a new [`Camera`][crate::Camera].
	#[doc(alias = "arv_camera_new")]
	pub fn new(name: Option<&str>) -> Result<Camera, glib::Error> {
		assert_initialized_main_thread!();
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_new(name.to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib_full(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	/// Creates a new [`Camera`][crate::Camera], using `device` as its internal device object.
	/// ## `device`
	/// a [`Device`][crate::Device]
	///
	/// # Returns
	///
	/// a new [`Camera`][crate::Camera].
	#[cfg(feature = "v0_8_6")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
	#[doc(alias = "arv_camera_new_with_device")]
	#[doc(alias = "new_with_device")]
	pub fn with_device(device: &impl IsA<Device>) -> Result<Camera, glib::Error> {
		skip_assert_initialized!();
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_new_with_device(device.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib_full(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}
}

unsafe impl Send for Camera {}

mod sealed {
	pub trait Sealed {}
	impl<T: super::IsA<super::Camera>> Sealed for T {}
}

/// Trait containing all [`struct@Camera`] methods.
///
/// # Implementors
///
/// [`Camera`][struct@crate::Camera]
pub trait CameraExt: IsA<Camera> + sealed::Sealed + 'static {
	#[doc(alias = "arv_camera_abort_acquisition")]
	fn abort_acquisition(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_abort_acquisition(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_acquisition")]
	fn acquisition(&self, timeout: u64) -> Result<Buffer, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_acquisition(self.as_ref().to_glib_none().0, timeout, &mut error);
			if error.is_null() {
				Ok(from_glib_full(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_8")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
	#[doc(alias = "arv_camera_are_chunks_available")]
	fn are_chunks_available(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok =
				ffi::arv_camera_are_chunks_available(self.as_ref().to_glib_none().0, &mut error);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_clear_triggers")]
	fn clear_triggers(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_clear_triggers(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_create_chunk_parser")]
	fn create_chunk_parser(&self) -> Option<ChunkParser> {
		unsafe {
			from_glib_full(ffi::arv_camera_create_chunk_parser(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[cfg(feature = "v0_8_27")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_27")))]
	#[doc(alias = "arv_camera_dup_available_black_levels")]
	fn dup_available_black_levels(&self) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_selectors = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_black_levels(
				self.as_ref().to_glib_none().0,
				n_selectors.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_selectors.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_camera_dup_available_components")]
	fn dup_available_components(&self) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_components = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_components(
				self.as_ref().to_glib_none().0,
				n_components.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_components.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_enumerations")]
	fn dup_available_enumerations(&self, feature: &str) -> Result<Vec<i64>, glib::Error> {
		unsafe {
			let mut n_values = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_enumerations(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				n_values.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_values.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_enumerations_as_display_names")]
	fn dup_available_enumerations_as_display_names(
		&self,
		feature: &str,
	) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_values = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_enumerations_as_display_names(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				n_values.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_values.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_enumerations_as_strings")]
	fn dup_available_enumerations_as_strings(
		&self,
		feature: &str,
	) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_values = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_enumerations_as_strings(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				n_values.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_values.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_27")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_27")))]
	#[doc(alias = "arv_camera_dup_available_gains")]
	fn dup_available_gains(&self) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_selectors = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_gains(
				self.as_ref().to_glib_none().0,
				n_selectors.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_selectors.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_pixel_formats")]
	fn dup_available_pixel_formats(&self) -> Result<Vec<i64>, glib::Error> {
		unsafe {
			let mut n_pixel_formats = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_pixel_formats(
				self.as_ref().to_glib_none().0,
				n_pixel_formats.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_pixel_formats.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_pixel_formats_as_display_names")]
	fn dup_available_pixel_formats_as_display_names(
		&self,
	) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_pixel_formats = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_pixel_formats_as_display_names(
				self.as_ref().to_glib_none().0,
				n_pixel_formats.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_pixel_formats.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_pixel_formats_as_strings")]
	fn dup_available_pixel_formats_as_strings(&self) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_pixel_formats = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_pixel_formats_as_strings(
				self.as_ref().to_glib_none().0,
				n_pixel_formats.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_pixel_formats.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_trigger_sources")]
	fn dup_available_trigger_sources(&self) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_sources = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_trigger_sources(
				self.as_ref().to_glib_none().0,
				n_sources.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_sources.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_dup_available_triggers")]
	fn dup_available_triggers(&self) -> Result<Vec<glib::GString>, glib::Error> {
		unsafe {
			let mut n_triggers = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_dup_available_triggers(
				self.as_ref().to_glib_none().0,
				n_triggers.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok(FromGlibContainer::from_glib_container_num(
					ret,
					n_triggers.assume_init() as _,
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	//#[cfg(feature = "v0_8_31")]
	//#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	//#[doc(alias = "arv_camera_dup_register")]
	//fn dup_register(&self, feature: &str) -> Result<(/*Unimplemented*/Option<Basic: Pointer>, u64), glib::Error> {
	//    unsafe { TODO: call ffi:arv_camera_dup_register() }
	//}

	#[doc(alias = "arv_camera_execute_command")]
	fn execute_command(&self, feature: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_execute_command(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_acquisition_mode")]
	#[doc(alias = "get_acquisition_mode")]
	fn acquisition_mode(&self) -> Result<AcquisitionMode, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_acquisition_mode(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_binning")]
	#[doc(alias = "get_binning")]
	fn binning(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut dx = std::mem::MaybeUninit::uninit();
			let mut dy = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_binning(
				self.as_ref().to_glib_none().0,
				dx.as_mut_ptr(),
				dy.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((dx.assume_init(), dy.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_19")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_19")))]
	#[doc(alias = "arv_camera_get_black_level")]
	#[doc(alias = "get_black_level")]
	fn black_level(&self) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_black_level(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_19")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_19")))]
	#[doc(alias = "arv_camera_get_black_level_auto")]
	#[doc(alias = "get_black_level_auto")]
	fn black_level_auto(&self) -> Result<Auto, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_black_level_auto(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_19")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_19")))]
	#[doc(alias = "arv_camera_get_black_level_bounds")]
	#[doc(alias = "get_black_level_bounds")]
	fn black_level_bounds(&self) -> Result<(f64, f64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_black_level_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_boolean")]
	#[doc(alias = "get_boolean")]
	fn boolean(&self, feature: &str) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_boolean(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_chunk_mode")]
	#[doc(alias = "get_chunk_mode")]
	fn chunk_mode(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_chunk_mode(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_chunk_state")]
	#[doc(alias = "get_chunk_state")]
	fn chunk_state(&self, chunk: &str) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_chunk_state(
				self.as_ref().to_glib_none().0,
				chunk.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_device")]
	#[doc(alias = "get_device")]
	fn device(&self) -> Option<Device> {
		unsafe { from_glib_none(ffi::arv_camera_get_device(self.as_ref().to_glib_none().0)) }
	}

	#[doc(alias = "arv_camera_get_device_id")]
	#[doc(alias = "get_device_id")]
	fn device_id(&self) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_device_id(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_8")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
	#[doc(alias = "arv_camera_get_device_serial_number")]
	#[doc(alias = "get_device_serial_number")]
	fn device_serial_number(&self) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_device_serial_number(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_exposure_time")]
	#[doc(alias = "get_exposure_time")]
	fn exposure_time(&self) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_exposure_time(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_exposure_time_auto")]
	#[doc(alias = "get_exposure_time_auto")]
	fn exposure_time_auto(&self) -> Result<Auto, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_exposure_time_auto(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_exposure_time_bounds")]
	#[doc(alias = "get_exposure_time_bounds")]
	fn exposure_time_bounds(&self) -> Result<(f64, f64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_exposure_time_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_31")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	#[doc(alias = "arv_camera_get_exposure_time_representation")]
	#[doc(alias = "get_exposure_time_representation")]
	fn exposure_time_representation(&self) -> GcRepresentation {
		unsafe {
			from_glib(ffi::arv_camera_get_exposure_time_representation(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[cfg(feature = "v0_8_31")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	#[doc(alias = "arv_camera_get_feature_representation")]
	#[doc(alias = "get_feature_representation")]
	fn feature_representation(&self, feature: &str) -> GcRepresentation {
		unsafe {
			from_glib(ffi::arv_camera_get_feature_representation(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_camera_get_float")]
	#[doc(alias = "get_float")]
	fn float(&self, feature: &str) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_float(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_float_bounds")]
	#[doc(alias = "get_float_bounds")]
	fn float_bounds(&self, feature: &str) -> Result<(f64, f64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_float_bounds(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_16")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_16")))]
	#[doc(alias = "arv_camera_get_float_increment")]
	#[doc(alias = "get_float_increment")]
	fn float_increment(&self, feature: &str) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_float_increment(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_frame_count")]
	#[doc(alias = "get_frame_count")]
	fn frame_count(&self) -> Result<i64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_frame_count(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_frame_count_bounds")]
	#[doc(alias = "get_frame_count_bounds")]
	fn frame_count_bounds(&self) -> Result<(i64, i64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_frame_count_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_frame_rate")]
	#[doc(alias = "get_frame_rate")]
	fn frame_rate(&self) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_frame_rate(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_frame_rate_bounds")]
	#[doc(alias = "get_frame_rate_bounds")]
	fn frame_rate_bounds(&self) -> Result<(f64, f64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_frame_rate_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_31")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	#[doc(alias = "arv_camera_get_frame_rate_enable")]
	#[doc(alias = "get_frame_rate_enable")]
	fn frame_rate_enable(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok =
				ffi::arv_camera_get_frame_rate_enable(self.as_ref().to_glib_none().0, &mut error);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_gain")]
	#[doc(alias = "get_gain")]
	fn gain(&self) -> Result<f64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_gain(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_gain_auto")]
	#[doc(alias = "get_gain_auto")]
	fn gain_auto(&self) -> Result<Auto, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_gain_auto(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_gain_bounds")]
	#[doc(alias = "get_gain_bounds")]
	fn gain_bounds(&self) -> Result<(f64, f64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_gain_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_31")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	#[doc(alias = "arv_camera_get_gain_representation")]
	#[doc(alias = "get_gain_representation")]
	fn gain_representation(&self) -> GcRepresentation {
		unsafe {
			from_glib(ffi::arv_camera_get_gain_representation(
				self.as_ref().to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_camera_get_height_bounds")]
	#[doc(alias = "get_height_bounds")]
	fn height_bounds(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_height_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_height_increment")]
	#[doc(alias = "get_height_increment")]
	fn height_increment(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_height_increment(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_integer")]
	#[doc(alias = "get_integer")]
	fn integer(&self, feature: &str) -> Result<i64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_integer(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_integer_bounds")]
	#[doc(alias = "get_integer_bounds")]
	fn integer_bounds(&self, feature: &str) -> Result<(i64, i64), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_integer_bounds(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_integer_increment")]
	#[doc(alias = "get_integer_increment")]
	fn integer_increment(&self, feature: &str) -> Result<i64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_integer_increment(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_model_name")]
	#[doc(alias = "get_model_name")]
	fn model_name(&self) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_model_name(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_payload")]
	#[doc(alias = "get_payload")]
	fn payload(&self) -> Result<u32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_payload(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_pixel_format")]
	#[doc(alias = "get_pixel_format")]
	fn pixel_format(&self) -> Result<PixelFormat, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_pixel_format(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_pixel_format_as_string")]
	#[doc(alias = "get_pixel_format_as_string")]
	fn pixel_format_as_string(&self) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_pixel_format_as_string(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_region")]
	#[doc(alias = "get_region")]
	fn region(&self) -> Result<(i32, i32, i32, i32), glib::Error> {
		unsafe {
			let mut x = std::mem::MaybeUninit::uninit();
			let mut y = std::mem::MaybeUninit::uninit();
			let mut width = std::mem::MaybeUninit::uninit();
			let mut height = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_region(
				self.as_ref().to_glib_none().0,
				x.as_mut_ptr(),
				y.as_mut_ptr(),
				width.as_mut_ptr(),
				height.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((
					x.assume_init(),
					y.assume_init(),
					width.assume_init(),
					height.assume_init(),
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_sensor_size")]
	#[doc(alias = "get_sensor_size")]
	fn sensor_size(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut width = std::mem::MaybeUninit::uninit();
			let mut height = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_sensor_size(
				self.as_ref().to_glib_none().0,
				width.as_mut_ptr(),
				height.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((width.assume_init(), height.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_string")]
	#[doc(alias = "get_string")]
	fn string(&self, feature: &str) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_string(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_trigger_source")]
	#[doc(alias = "get_trigger_source")]
	fn trigger_source(&self) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_trigger_source(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_vendor_name")]
	#[doc(alias = "get_vendor_name")]
	fn vendor_name(&self) -> Result<glib::GString, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_get_vendor_name(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib_none(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_width_bounds")]
	#[doc(alias = "get_width_bounds")]
	fn width_bounds(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_width_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_width_increment")]
	#[doc(alias = "get_width_increment")]
	fn width_increment(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_width_increment(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_x_binning_bounds")]
	#[doc(alias = "get_x_binning_bounds")]
	fn x_binning_bounds(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_x_binning_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_x_binning_increment")]
	#[doc(alias = "get_x_binning_increment")]
	fn x_binning_increment(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_x_binning_increment(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_x_offset_bounds")]
	#[doc(alias = "get_x_offset_bounds")]
	fn x_offset_bounds(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_x_offset_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_x_offset_increment")]
	#[doc(alias = "get_x_offset_increment")]
	fn x_offset_increment(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_x_offset_increment(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_y_binning_bounds")]
	#[doc(alias = "get_y_binning_bounds")]
	fn y_binning_bounds(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_y_binning_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_y_binning_increment")]
	#[doc(alias = "get_y_binning_increment")]
	fn y_binning_increment(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_y_binning_increment(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_y_offset_bounds")]
	#[doc(alias = "get_y_offset_bounds")]
	fn y_offset_bounds(&self) -> Result<(i32, i32), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_get_y_offset_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_get_y_offset_increment")]
	#[doc(alias = "get_y_offset_increment")]
	fn y_offset_increment(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_get_y_offset_increment(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_auto_packet_size")]
	fn gv_auto_packet_size(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok =
				ffi::arv_camera_gv_auto_packet_size(self.as_ref().to_glib_none().0, &mut error) as i32;
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_get_current_stream_channel")]
	fn gv_get_current_stream_channel(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_gv_get_current_stream_channel(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_camera_gv_get_ip_configuration_mode")]
	fn gv_get_ip_configuration_mode(&self) -> Result<GvIpConfigurationMode, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_gv_get_ip_configuration_mode(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_camera_gv_get_multipart")]
	fn gv_get_multipart(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok =
				ffi::arv_camera_gv_get_multipart(self.as_ref().to_glib_none().0, &mut error);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_25")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_25")))]
	#[doc(alias = "arv_camera_gv_get_n_network_interfaces")]
	fn gv_get_n_network_interfaces(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_gv_get_n_network_interfaces(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_get_n_stream_channels")]
	fn gv_get_n_stream_channels(&self) -> Result<i32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_gv_get_n_stream_channels(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_get_packet_delay")]
	fn gv_get_packet_delay(&self) -> Result<i64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_gv_get_packet_delay(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_get_packet_size")]
	fn gv_get_packet_size(&self) -> Result<u32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_gv_get_packet_size(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_camera_gv_get_persistent_ip")]
	fn gv_get_persistent_ip(
		&self,
	) -> Result<(gio::InetAddress, gio::InetAddressMask, gio::InetAddress), glib::Error> {
		unsafe {
			let mut ip = std::ptr::null_mut();
			let mut mask = std::ptr::null_mut();
			let mut gateway = std::ptr::null_mut();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_get_persistent_ip(
				self.as_ref().to_glib_none().0,
				&mut ip,
				&mut mask,
				&mut gateway,
				&mut error,
			);
			if error.is_null() {
				Ok((
					from_glib_full(ip),
					from_glib_full(mask),
					from_glib_full(gateway),
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_camera_gv_is_multipart_supported")]
	fn gv_is_multipart_supported(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_gv_is_multipart_supported(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_select_stream_channel")]
	fn gv_select_stream_channel(&self, channel_id: i32) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_select_stream_channel(
				self.as_ref().to_glib_none().0,
				channel_id,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_camera_gv_set_ip_configuration_mode")]
	fn gv_set_ip_configuration_mode(&self, mode: GvIpConfigurationMode) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_set_ip_configuration_mode(
				self.as_ref().to_glib_none().0,
				mode.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_camera_gv_set_multipart")]
	fn gv_set_multipart(&self, enable: bool) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_set_multipart(
				self.as_ref().to_glib_none().0,
				enable.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_set_packet_delay")]
	fn gv_set_packet_delay(&self, delay_ns: i64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_set_packet_delay(
				self.as_ref().to_glib_none().0,
				delay_ns,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_set_packet_size")]
	fn gv_set_packet_size(&self, packet_size: i32) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_set_packet_size(
				self.as_ref().to_glib_none().0,
				packet_size,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_3")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_3")))]
	#[doc(alias = "arv_camera_gv_set_packet_size_adjustment")]
	fn gv_set_packet_size_adjustment(&self, adjustment: GvPacketSizeAdjustment) {
		unsafe {
			ffi::arv_camera_gv_set_packet_size_adjustment(
				self.as_ref().to_glib_none().0,
				adjustment.into_glib(),
			);
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_camera_gv_set_persistent_ip")]
	fn gv_set_persistent_ip(
		&self,
		ip: &impl IsA<gio::InetAddress>,
		mask: &impl IsA<gio::InetAddressMask>,
		gateway: &impl IsA<gio::InetAddress>,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_set_persistent_ip(
				self.as_ref().to_glib_none().0,
				ip.as_ref().to_glib_none().0,
				mask.as_ref().to_glib_none().0,
				gateway.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_camera_gv_set_persistent_ip_from_string")]
	fn gv_set_persistent_ip_from_string(
		&self,
		ip: &str,
		mask: &str,
		gateway: &str,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_gv_set_persistent_ip_from_string(
				self.as_ref().to_glib_none().0,
				ip.to_glib_none().0,
				mask.to_glib_none().0,
				gateway.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_gv_set_stream_options")]
	fn gv_set_stream_options(&self, options: GvStreamOption) {
		unsafe {
			ffi::arv_camera_gv_set_stream_options(
				self.as_ref().to_glib_none().0,
				options.into_glib(),
			);
		}
	}

	#[doc(alias = "arv_camera_is_binning_available")]
	fn is_binning_available(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_is_binning_available(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_19")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_19")))]
	#[doc(alias = "arv_camera_is_black_level_auto_available")]
	fn is_black_level_auto_available(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_is_black_level_auto_available(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_19")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_19")))]
	#[doc(alias = "arv_camera_is_black_level_available")]
	fn is_black_level_available(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_is_black_level_available(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_25")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_25")))]
	#[doc(alias = "arv_camera_is_component_available")]
	fn is_component_available(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok =
				ffi::arv_camera_is_component_available(self.as_ref().to_glib_none().0, &mut error);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_17")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_17")))]
	#[doc(alias = "arv_camera_is_enumeration_entry_available")]
	fn is_enumeration_entry_available(
		&self,
		feature: &str,
		entry: &str,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_is_enumeration_entry_available(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				entry.to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_exposure_auto_available")]
	fn is_exposure_auto_available(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_is_exposure_auto_available(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_exposure_time_available")]
	fn is_exposure_time_available(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_is_exposure_time_available(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_feature_available")]
	fn is_feature_available(&self, feature: &str) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_is_feature_available(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_camera_is_feature_implemented")]
	fn is_feature_implemented(&self, feature: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_is_feature_implemented(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_frame_rate_available")]
	fn is_frame_rate_available(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_is_frame_rate_available(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_gain_auto_available")]
	fn is_gain_auto_available(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_camera_is_gain_auto_available(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_gain_available")]
	fn is_gain_available(&self) -> Result<bool, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_is_gain_available(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_gv_device")]
	fn is_gv_device(&self) -> bool {
		unsafe { from_glib(ffi::arv_camera_is_gv_device(self.as_ref().to_glib_none().0)) }
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_camera_is_region_offset_available")]
	fn is_region_offset_available(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_is_region_offset_available(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_17")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_17")))]
	#[doc(alias = "arv_camera_is_software_trigger_supported")]
	fn is_software_trigger_supported(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_is_software_trigger_supported(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_is_uv_device")]
	fn is_uv_device(&self) -> bool {
		unsafe { from_glib(ffi::arv_camera_is_uv_device(self.as_ref().to_glib_none().0)) }
	}

	#[cfg(feature = "v0_8_23")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_23")))]
	#[doc(alias = "arv_camera_select_and_enable_component")]
	fn select_and_enable_component(
		&self,
		component: &str,
		disable_others: bool,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_select_and_enable_component(
				self.as_ref().to_glib_none().0,
				component.to_glib_none().0,
				disable_others.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_27")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_27")))]
	#[doc(alias = "arv_camera_select_black_level")]
	fn select_black_level(&self, selector: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_select_black_level(
				self.as_ref().to_glib_none().0,
				selector.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_25")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_25")))]
	#[doc(alias = "arv_camera_select_component")]
	fn select_component(
		&self,
		component: &str,
		flags: ComponentSelectionFlags,
	) -> Result<u32, glib::Error> {
		unsafe {
			let mut component_id = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_select_component(
				self.as_ref().to_glib_none().0,
				component.to_glib_none().0,
				flags.into_glib(),
				component_id.as_mut_ptr(),
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(component_id.assume_init())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_27")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_27")))]
	#[doc(alias = "arv_camera_select_gain")]
	fn select_gain(&self, selector: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_select_gain(
				self.as_ref().to_glib_none().0,
				selector.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_camera_set_access_check_policy")]
	fn set_access_check_policy(&self, policy: AccessCheckPolicy) {
		unsafe {
			ffi::arv_camera_set_access_check_policy(
				self.as_ref().to_glib_none().0,
				policy.into_glib(),
			);
		}
	}

	#[doc(alias = "arv_camera_set_acquisition_mode")]
	fn set_acquisition_mode(&self, value: AcquisitionMode) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_acquisition_mode(
				self.as_ref().to_glib_none().0,
				value.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_binning")]
	fn set_binning(&self, dx: i32, dy: i32) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_binning(self.as_ref().to_glib_none().0, dx, dy, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_19")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_19")))]
	#[doc(alias = "arv_camera_set_black_level")]
	fn set_black_level(&self, blacklevel: f64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_black_level(
				self.as_ref().to_glib_none().0,
				blacklevel,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_19")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_19")))]
	#[doc(alias = "arv_camera_set_black_level_auto")]
	fn set_black_level_auto(&self, auto_mode: Auto) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_black_level_auto(
				self.as_ref().to_glib_none().0,
				auto_mode.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_boolean")]
	fn set_boolean(&self, feature: &str, value: bool) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_boolean(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_chunk_mode")]
	fn set_chunk_mode(&self, is_active: bool) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_chunk_mode(
				self.as_ref().to_glib_none().0,
				is_active.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_chunk_state")]
	fn set_chunk_state(&self, chunk: &str, is_enabled: bool) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_chunk_state(
				self.as_ref().to_glib_none().0,
				chunk.to_glib_none().0,
				is_enabled.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_chunks")]
	fn set_chunks(&self, chunk_list: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_chunks(
				self.as_ref().to_glib_none().0,
				chunk_list.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_exposure_mode")]
	fn set_exposure_mode(&self, mode: ExposureMode) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_exposure_mode(
				self.as_ref().to_glib_none().0,
				mode.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_exposure_time")]
	fn set_exposure_time(&self, exposure_time_us: f64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_exposure_time(
				self.as_ref().to_glib_none().0,
				exposure_time_us,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_exposure_time_auto")]
	fn set_exposure_time_auto(&self, auto_mode: Auto) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_exposure_time_auto(
				self.as_ref().to_glib_none().0,
				auto_mode.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_float")]
	fn set_float(&self, feature: &str, value: f64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_float(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_frame_count")]
	fn set_frame_count(&self, frame_count: i64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_frame_count(
				self.as_ref().to_glib_none().0,
				frame_count,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_frame_rate")]
	fn set_frame_rate(&self, frame_rate: f64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_frame_rate(
				self.as_ref().to_glib_none().0,
				frame_rate,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_frame_rate_enable")]
	fn set_frame_rate_enable(&self, enable: bool) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_frame_rate_enable(
				self.as_ref().to_glib_none().0,
				enable.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_gain")]
	fn set_gain(&self, gain: f64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_gain(self.as_ref().to_glib_none().0, gain, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_gain_auto")]
	fn set_gain_auto(&self, auto_mode: Auto) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_gain_auto(
				self.as_ref().to_glib_none().0,
				auto_mode.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_integer")]
	fn set_integer(&self, feature: &str, value: i64) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_integer(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_pixel_format")]
	fn set_pixel_format(&self, format: PixelFormat) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_pixel_format(
				self.as_ref().to_glib_none().0,
				format.into_glib(),
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_pixel_format_from_string")]
	fn set_pixel_format_from_string(&self, format: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_pixel_format_from_string(
				self.as_ref().to_glib_none().0,
				format.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_8")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
	#[doc(alias = "arv_camera_set_range_check_policy")]
	fn set_range_check_policy(&self, policy: RangeCheckPolicy) {
		unsafe {
			ffi::arv_camera_set_range_check_policy(
				self.as_ref().to_glib_none().0,
				policy.into_glib(),
			);
		}
	}

	#[doc(alias = "arv_camera_set_region")]
	fn set_region(&self, x: i32, y: i32, width: i32, height: i32) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_region(
				self.as_ref().to_glib_none().0,
				x,
				y,
				width,
				height,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	//#[cfg(feature = "v0_8_31")]
	//#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_31")))]
	//#[doc(alias = "arv_camera_set_register")]
	//fn set_register(&self, feature: &str, value: /*Unimplemented*/Option<Basic: Pointer>) -> Result<(), glib::Error> {
	//    unsafe { TODO: call ffi:arv_camera_set_register() }
	//}

	#[cfg(feature = "v0_8_8")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
	#[doc(alias = "arv_camera_set_register_cache_policy")]
	fn set_register_cache_policy(&self, policy: RegisterCachePolicy) {
		unsafe {
			ffi::arv_camera_set_register_cache_policy(
				self.as_ref().to_glib_none().0,
				policy.into_glib(),
			);
		}
	}

	#[doc(alias = "arv_camera_set_string")]
	fn set_string(&self, feature: &str, value: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_string(
				self.as_ref().to_glib_none().0,
				feature.to_glib_none().0,
				value.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_trigger")]
	fn set_trigger(&self, source: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_trigger(
				self.as_ref().to_glib_none().0,
				source.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_set_trigger_source")]
	fn set_trigger_source(&self, source: &str) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_set_trigger_source(
				self.as_ref().to_glib_none().0,
				source.to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_software_trigger")]
	fn software_trigger(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_software_trigger(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_start_acquisition")]
	fn start_acquisition(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_start_acquisition(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_stop_acquisition")]
	fn stop_acquisition(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_stop_acquisition(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_uv_get_bandwidth")]
	fn uv_get_bandwidth(&self) -> Result<u32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_camera_uv_get_bandwidth(self.as_ref().to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_uv_get_bandwidth_bounds")]
	fn uv_get_bandwidth_bounds(&self) -> Result<(u32, u32), glib::Error> {
		unsafe {
			let mut min = std::mem::MaybeUninit::uninit();
			let mut max = std::mem::MaybeUninit::uninit();
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_uv_get_bandwidth_bounds(
				self.as_ref().to_glib_none().0,
				min.as_mut_ptr(),
				max.as_mut_ptr(),
				&mut error,
			);
			if error.is_null() {
				Ok((min.assume_init(), max.assume_init()))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_uv_is_bandwidth_control_available")]
	fn uv_is_bandwidth_control_available(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_camera_uv_is_bandwidth_control_available(
				self.as_ref().to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_camera_uv_set_bandwidth")]
	fn uv_set_bandwidth(&self, bandwidth: u32) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ = ffi::arv_camera_uv_set_bandwidth(
				self.as_ref().to_glib_none().0,
				bandwidth,
				&mut error,
			);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[cfg(feature = "v0_8_17")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_17")))]
	#[doc(alias = "arv_camera_uv_set_usb_mode")]
	fn uv_set_usb_mode(&self, usb_mode: UvUsbMode) {
		unsafe {
			ffi::arv_camera_uv_set_usb_mode(self.as_ref().to_glib_none().0, usb_mode.into_glib());
		}
	}
}

impl<O: IsA<Camera>> CameraExt for O {}
