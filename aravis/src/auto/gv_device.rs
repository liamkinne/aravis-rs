// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

#[cfg(feature = "v0_8_22")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
use crate::GvIpConfigurationMode;
use crate::{ffi, Device, GvPacketSizeAdjustment, GvStreamOption};
use glib::{
	prelude::*,
	signal::{connect_raw, SignalHandlerId},
	translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
///
///
/// ## Properties
///
///
/// #### `device-address`
///  Writeable | Construct Only
///
///
/// #### `interface-address`
///  Writeable | Construct Only
///
///
/// #### `packet-size-adjustment`
///  Readable | Writeable | Construct
///
/// # Implements
///
/// [`DeviceExt`][trait@crate::prelude::DeviceExt], [`trait@glib::ObjectExt`]
	#[doc(alias = "ArvGvDevice")]
	pub struct GvDevice(Object<ffi::ArvGvDevice, ffi::ArvGvDeviceClass>) @extends Device;

	match fn {
		type_ => || ffi::arv_gv_device_get_type(),
	}
}

impl GvDevice {
/// ## `interface_address`
/// address of the interface connected to the device
/// ## `device_address`
/// device address
///
/// # Returns
///
/// a newly created [`Device`][crate::Device] using GigE protocol
	#[doc(alias = "arv_gv_device_new")]
	pub fn new(
		interface_address: &impl IsA<gio::InetAddress>,
		device_address: &impl IsA<gio::InetAddress>,
	) -> Result<GvDevice, glib::Error> {
		assert_initialized_main_thread!();
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_gv_device_new(
				interface_address.as_ref().to_glib_none().0,
				device_address.as_ref().to_glib_none().0,
				&mut error,
			);
			if error.is_null() {
				Ok(Device::from_glib_full(ret).unsafe_cast())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

/// Automatically determine the biggest packet size that can be used data streaming, and set ArvGevSCPSPacketSize value
/// accordingly. This function relies on the GevSCPSFireTestPacket feature.
///
/// # Returns
///
/// The automatic packet size, in bytes, or the current one if GevSCPSFireTestPacket is not supported.
	#[doc(alias = "arv_gv_device_auto_packet_size")]
	pub fn auto_packet_size(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok =
				ffi::arv_gv_device_auto_packet_size(self.to_glib_none().0, &mut error) as i32;
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

/// Get the current IP address setting of device.
///
/// # Returns
///
/// [`true`] on success
///
/// ## `ip`
/// a IP address placeholder
///
/// ## `mask`
/// a netmask placeholder
///
/// ## `gateway`
/// a gateway IP address placeholder
	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_gv_device_get_current_ip")]
	#[doc(alias = "get_current_ip")]
	pub fn current_ip(
		&self,
	) -> Result<(gio::InetAddress, gio::InetAddressMask, gio::InetAddress), glib::Error> {
		unsafe {
			let mut ip = std::ptr::null_mut();
			let mut mask = std::ptr::null_mut();
			let mut gateway = std::ptr::null_mut();
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_gv_device_get_current_ip(
				self.to_glib_none().0,
				&mut ip,
				&mut mask,
				&mut gateway,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok((
					from_glib_full(ip),
					from_glib_full(mask),
					from_glib_full(gateway),
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

///
/// # Returns
///
/// the device IP address.
	#[doc(alias = "arv_gv_device_get_device_address")]
	#[doc(alias = "get_device_address")]
	pub fn device_address(&self) -> Option<gio::SocketAddress> {
		unsafe { from_glib_none(ffi::arv_gv_device_get_device_address(self.to_glib_none().0)) }
	}

///
/// # Returns
///
/// the device host interface IP address.
	#[doc(alias = "arv_gv_device_get_interface_address")]
	#[doc(alias = "get_interface_address")]
	pub fn interface_address(&self) -> Option<gio::SocketAddress> {
		unsafe {
			from_glib_none(ffi::arv_gv_device_get_interface_address(
				self.to_glib_none().0,
			))
		}
	}

/// Get the IP address configuration mode.
///
/// # Returns
///
/// IP address configuration mode
	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_gv_device_get_ip_configuration_mode")]
	#[doc(alias = "get_ip_configuration_mode")]
	pub fn ip_configuration_mode(&self) -> Result<GvIpConfigurationMode, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_gv_device_get_ip_configuration_mode(self.to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(from_glib(ret))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_gv_device_get_packet_size")]
	#[doc(alias = "get_packet_size")]
	pub fn packet_size(&self) -> Result<u32, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret = ffi::arv_gv_device_get_packet_size(self.to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

/// Get the persistent IP address setting of device.
///
/// # Returns
///
/// [`true`] on success
///
/// ## `ip`
/// a IP address placeholder
///
/// ## `mask`
/// a netmask placeholder
///
/// ## `gateway`
/// a gateway IP address placeholder
	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_gv_device_get_persistent_ip")]
	#[doc(alias = "get_persistent_ip")]
	pub fn persistent_ip(
		&self,
	) -> Result<(gio::InetAddress, gio::InetAddressMask, gio::InetAddress), glib::Error> {
		unsafe {
			let mut ip = std::ptr::null_mut();
			let mut mask = std::ptr::null_mut();
			let mut gateway = std::ptr::null_mut();
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_gv_device_get_persistent_ip(
				self.to_glib_none().0,
				&mut ip,
				&mut mask,
				&mut gateway,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok((
					from_glib_full(ip),
					from_glib_full(mask),
					from_glib_full(gateway),
				))
			} else {
				Err(from_glib_full(error))
			}
		}
	}

///
/// # Returns
///
/// options for stream creation
	#[doc(alias = "arv_gv_device_get_stream_options")]
	#[doc(alias = "get_stream_options")]
	pub fn stream_options(&self) -> GvStreamOption {
		unsafe { from_glib(ffi::arv_gv_device_get_stream_options(self.to_glib_none().0)) }
	}

	#[doc(alias = "arv_gv_device_get_timestamp_tick_frequency")]
	#[doc(alias = "get_timestamp_tick_frequency")]
	pub fn timestamp_tick_frequency(&self) -> Result<u64, glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let ret =
				ffi::arv_gv_device_get_timestamp_tick_frequency(self.to_glib_none().0, &mut error);
			if error.is_null() {
				Ok(ret)
			} else {
				Err(from_glib_full(error))
			}
		}
	}

///
/// # Returns
///
/// value indicating whether the ArvGvDevice has control access to the camera
	#[doc(alias = "arv_gv_device_is_controller")]
	pub fn is_controller(&self) -> bool {
		unsafe { from_glib(ffi::arv_gv_device_is_controller(self.to_glib_none().0)) }
	}

///
/// # Returns
///
/// whether the control was successfully relinquished
	#[cfg(feature = "v0_8_3")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_3")))]
	#[doc(alias = "arv_gv_device_leave_control")]
	pub fn leave_control(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_gv_device_leave_control(self.to_glib_none().0, &mut error);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

/// Sets the IP address configuration mode.
/// Available modes are ARV_GV_IP_CONFIGURATION_MODE_DHCP, ARV_GV_IP_CONFIGURATION_MODE_PERSISTENT_IP,
/// ARV_GV_IP_CONFIGURATION_MODE_LLA
/// ## `mode`
/// IP address configuration mode
///
/// # Returns
///
/// [`true`] on success
	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_gv_device_set_ip_configuration_mode")]
	pub fn set_ip_configuration_mode(
		&self,
		mode: GvIpConfigurationMode,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_gv_device_set_ip_configuration_mode(
				self.to_glib_none().0,
				mode.into_glib(),
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "arv_gv_device_set_packet_size")]
	pub fn set_packet_size(&self, packet_size: i32) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let _ =
				ffi::arv_gv_device_set_packet_size(self.to_glib_none().0, packet_size, &mut error);
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

/// Sets the option for the packet size adjustment happening at stream object creation. See
/// [`auto_packet_size()`][Self::auto_packet_size()] for a description of the packet adjustment feature. The default behaviour is
/// `ARV_GV_PACKET_SIZE_ADJUSTEMENT_ON_FAILURE_ONCE`, which means the packet size is adjusted if the current packet size
/// check fails, and only the first time `arv_device_create_stream()` is successfully called during `self` instance
/// life.
/// ## `adjustment`
/// a [`GvPacketSizeAdjustment`][crate::GvPacketSizeAdjustment] option
	#[cfg(feature = "v0_8_3")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_3")))]
	#[doc(alias = "arv_gv_device_set_packet_size_adjustment")]
	#[doc(alias = "packet-size-adjustment")]
	pub fn set_packet_size_adjustment(&self, adjustment: GvPacketSizeAdjustment) {
		unsafe {
			ffi::arv_gv_device_set_packet_size_adjustment(
				self.to_glib_none().0,
				adjustment.into_glib(),
			);
		}
	}

/// Sets the persistent IP address to device.
/// Also disable DHCP then enable persistent IP mode.
/// ## `ip`
/// IPv4 address
/// ## `mask`
/// Netmask
/// ## `gateway`
/// Gateway IPv4 address
///
/// # Returns
///
/// [`true`] on success
	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_gv_device_set_persistent_ip")]
	pub fn set_persistent_ip(
		&self,
		ip: Option<&impl IsA<gio::InetAddress>>,
		mask: Option<&impl IsA<gio::InetAddressMask>>,
		gateway: Option<&impl IsA<gio::InetAddress>>,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_gv_device_set_persistent_ip(
				self.to_glib_none().0,
				ip.map(|p| p.as_ref()).to_glib_none().0,
				mask.map(|p| p.as_ref()).to_glib_none().0,
				gateway.map(|p| p.as_ref()).to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

/// Sets the persistent IP address to device.
/// ## `ip`
/// IPv4 address in string format
/// ## `mask`
/// netmask in string format
/// ## `gateway`
/// Gateway IPv4 address in string format
///
/// # Returns
///
/// [`true`] on success
	#[cfg(feature = "v0_8_22")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_22")))]
	#[doc(alias = "arv_gv_device_set_persistent_ip_from_string")]
	pub fn set_persistent_ip_from_string(
		&self,
		ip: Option<&str>,
		mask: Option<&str>,
		gateway: Option<&str>,
	) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_gv_device_set_persistent_ip_from_string(
				self.to_glib_none().0,
				ip.to_glib_none().0,
				mask.to_glib_none().0,
				gateway.to_glib_none().0,
				&mut error,
			);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

/// Sets the option used during stream creation. It must be called before `arv_device_create_stream()`.
/// ## `options`
/// options for stream creation
	#[doc(alias = "arv_gv_device_set_stream_options")]
	pub fn set_stream_options(&self, options: GvStreamOption) {
		unsafe {
			ffi::arv_gv_device_set_stream_options(self.to_glib_none().0, options.into_glib());
		}
	}

///
/// # Returns
///
/// whether the control was successfully acquired
	#[cfg(feature = "v0_8_3")]
	#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_3")))]
	#[doc(alias = "arv_gv_device_take_control")]
	pub fn take_control(&self) -> Result<(), glib::Error> {
		unsafe {
			let mut error = std::ptr::null_mut();
			let is_ok = ffi::arv_gv_device_take_control(self.to_glib_none().0, &mut error);
			debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
			if error.is_null() {
				Ok(())
			} else {
				Err(from_glib_full(error))
			}
		}
	}

	#[doc(alias = "packet-size-adjustment")]
	pub fn packet_size_adjustment(&self) -> GvPacketSizeAdjustment {
		ObjectExt::property(self, "packet-size-adjustment")
	}

	#[cfg(not(feature = "v0_8_3"))]
	#[cfg_attr(docsrs, doc(cfg(not(feature = "v0_8_3"))))]
	#[doc(alias = "packet-size-adjustment")]
	pub fn set_packet_size_adjustment(&self, packet_size_adjustment: GvPacketSizeAdjustment) {
		ObjectExt::set_property(self, "packet-size-adjustment", packet_size_adjustment)
	}

	#[doc(alias = "packet-size-adjustment")]
	pub fn connect_packet_size_adjustment_notify<F: Fn(&Self) + Send + 'static>(
		&self,
		f: F,
	) -> SignalHandlerId {
		unsafe extern "C" fn notify_packet_size_adjustment_trampoline<
			F: Fn(&GvDevice) + Send + 'static,
		>(
			this: *mut ffi::ArvGvDevice,
			_param_spec: glib::ffi::gpointer,
			f: glib::ffi::gpointer,
		) {
			let f: &F = &*(f as *const F);
			f(&from_glib_borrow(this))
		}
		unsafe {
			let f: Box_<F> = Box_::new(f);
			connect_raw(
				self.as_ptr() as *mut _,
				b"notify::packet-size-adjustment\0".as_ptr() as *const _,
				Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
					notify_packet_size_adjustment_trampoline::<F> as *const (),
				)),
				Box_::into_raw(f),
			)
		}
	}
}

unsafe impl Send for GvDevice {}
