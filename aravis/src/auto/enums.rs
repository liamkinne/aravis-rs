// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvAccessCheckPolicy")]
pub enum AccessCheckPolicy {
	/// never check the register access mode
	#[doc(alias = "ARV_ACCESS_CHECK_POLICY_DISABLE")]
	Disable,
	/// always check the register access mode
	#[doc(alias = "ARV_ACCESS_CHECK_POLICY_ENABLE")]
	Enable,
	#[doc(hidden)]
	__Unknown(i32),
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
#[doc(hidden)]
impl IntoGlib for AccessCheckPolicy {
	type GlibType = ffi::ArvAccessCheckPolicy;

	#[inline]
	fn into_glib(self) -> ffi::ArvAccessCheckPolicy {
		match self {
			Self::Disable => ffi::ARV_ACCESS_CHECK_POLICY_DISABLE,
			Self::Enable => ffi::ARV_ACCESS_CHECK_POLICY_ENABLE,
			Self::__Unknown(value) => value,
		}
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
#[doc(hidden)]
impl FromGlib<ffi::ArvAccessCheckPolicy> for AccessCheckPolicy {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvAccessCheckPolicy) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_ACCESS_CHECK_POLICY_DISABLE => Self::Disable,
			ffi::ARV_ACCESS_CHECK_POLICY_ENABLE => Self::Enable,
			value => Self::__Unknown(value),
		}
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl StaticType for AccessCheckPolicy {
	#[inline]
	#[doc(alias = "arv_access_check_policy_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_access_check_policy_get_type()) }
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl glib::HasParamSpec for AccessCheckPolicy {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl glib::value::ValueType for AccessCheckPolicy {
	type Type = Self;
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for AccessCheckPolicy {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl ToValue for AccessCheckPolicy {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl From<AccessCheckPolicy> for glib::Value {
	#[inline]
	fn from(v: AccessCheckPolicy) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvAcquisitionMode")]
pub enum AcquisitionMode {
	/// frames are captured continuously until stopped with the AcquisitionStop command.
	#[doc(alias = "ARV_ACQUISITION_MODE_CONTINUOUS")]
	Continuous,
	/// only one frame will be acquired
	#[doc(alias = "ARV_ACQUISITION_MODE_SINGLE_FRAME")]
	SingleFrame,
	/// the number of frames specified by AcquisitionFrameCount is captured.
	#[doc(alias = "ARV_ACQUISITION_MODE_MULTI_FRAME")]
	MultiFrame,
	#[doc(hidden)]
	__Unknown(i32),
}

impl AcquisitionMode {
	#[doc(alias = "arv_acquisition_mode_from_string")]
	pub fn from_string(string: &str) -> AcquisitionMode {
		assert_initialized_main_thread!();
		unsafe {
			from_glib(ffi::arv_acquisition_mode_from_string(
				string.to_glib_none().0,
			))
		}
	}

	#[doc(alias = "arv_acquisition_mode_to_string")]
	#[doc(alias = "to_string")]
	pub fn to_str(self) -> Option<glib::GString> {
		assert_initialized_main_thread!();
		unsafe { from_glib_none(ffi::arv_acquisition_mode_to_string(self.into_glib())) }
	}
}

#[doc(hidden)]
impl IntoGlib for AcquisitionMode {
	type GlibType = ffi::ArvAcquisitionMode;

	#[inline]
	fn into_glib(self) -> ffi::ArvAcquisitionMode {
		match self {
			Self::Continuous => ffi::ARV_ACQUISITION_MODE_CONTINUOUS,
			Self::SingleFrame => ffi::ARV_ACQUISITION_MODE_SINGLE_FRAME,
			Self::MultiFrame => ffi::ARV_ACQUISITION_MODE_MULTI_FRAME,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvAcquisitionMode> for AcquisitionMode {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvAcquisitionMode) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_ACQUISITION_MODE_CONTINUOUS => Self::Continuous,
			ffi::ARV_ACQUISITION_MODE_SINGLE_FRAME => Self::SingleFrame,
			ffi::ARV_ACQUISITION_MODE_MULTI_FRAME => Self::MultiFrame,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for AcquisitionMode {
	#[inline]
	#[doc(alias = "arv_acquisition_mode_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_acquisition_mode_get_type()) }
	}
}

impl glib::HasParamSpec for AcquisitionMode {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for AcquisitionMode {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AcquisitionMode {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for AcquisitionMode {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<AcquisitionMode> for glib::Value {
	#[inline]
	fn from(v: AcquisitionMode) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvAuto")]
pub enum Auto {
	/// manual setting
	#[doc(alias = "ARV_AUTO_OFF")]
	Off,
	/// automatic setting done once, then returns to manual
	#[doc(alias = "ARV_AUTO_ONCE")]
	Once,
	/// setting is adjusted continuously
	#[doc(alias = "ARV_AUTO_CONTINUOUS")]
	Continuous,
	#[doc(hidden)]
	__Unknown(i32),
}

impl Auto {
	#[doc(alias = "arv_auto_from_string")]
	pub fn from_string(string: &str) -> Auto {
		assert_initialized_main_thread!();
		unsafe { from_glib(ffi::arv_auto_from_string(string.to_glib_none().0)) }
	}

	#[doc(alias = "arv_auto_to_string")]
	#[doc(alias = "to_string")]
	pub fn to_str(self) -> Option<glib::GString> {
		assert_initialized_main_thread!();
		unsafe { from_glib_none(ffi::arv_auto_to_string(self.into_glib())) }
	}
}

#[doc(hidden)]
impl IntoGlib for Auto {
	type GlibType = ffi::ArvAuto;

	#[inline]
	fn into_glib(self) -> ffi::ArvAuto {
		match self {
			Self::Off => ffi::ARV_AUTO_OFF,
			Self::Once => ffi::ARV_AUTO_ONCE,
			Self::Continuous => ffi::ARV_AUTO_CONTINUOUS,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvAuto> for Auto {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvAuto) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_AUTO_OFF => Self::Off,
			ffi::ARV_AUTO_ONCE => Self::Once,
			ffi::ARV_AUTO_CONTINUOUS => Self::Continuous,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for Auto {
	#[inline]
	#[doc(alias = "arv_auto_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_auto_get_type()) }
	}
}

impl glib::HasParamSpec for Auto {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for Auto {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Auto {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for Auto {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<Auto> for glib::Value {
	#[inline]
	fn from(v: Auto) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvBufferPayloadType")]
pub enum BufferPayloadType {
	/// unknown payload type
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN")]
	Unknown,
	/// no data
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_NO_DATA")]
	NoData,
	/// image data
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_IMAGE")]
	Image,
	/// raw data (not supported)
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_RAWDATA")]
	Rawdata,
	/// file (not supported)
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_FILE")]
	File,
	/// chunk data (not supported)
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA")]
	ChunkData,
	/// extended chunk data
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA")]
	ExtendedChunkData,
	/// JPEG data (not supported)
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_JPEG")]
	Jpeg,
	/// JPEG2000 data (not supported)
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_JPEG2000")]
	Jpeg2000,
	/// h264 data (not supported)
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_H264")]
	H264,
	/// multizone image (not supported)
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE")]
	MultizoneImage,
	/// multipart data
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_MULTIPART")]
	Multipart,
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_GENDC_CONTAINER")]
	GendcContainer,
	#[doc(alias = "ARV_BUFFER_PAYLOAD_TYPE_GENDC_COMPONENT_DATA")]
	GendcComponentData,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BufferPayloadType {
	type GlibType = ffi::ArvBufferPayloadType;

	fn into_glib(self) -> ffi::ArvBufferPayloadType {
		match self {
			Self::Unknown => ffi::ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN,
			Self::NoData => ffi::ARV_BUFFER_PAYLOAD_TYPE_NO_DATA,
			Self::Image => ffi::ARV_BUFFER_PAYLOAD_TYPE_IMAGE,
			Self::Rawdata => ffi::ARV_BUFFER_PAYLOAD_TYPE_RAWDATA,
			Self::File => ffi::ARV_BUFFER_PAYLOAD_TYPE_FILE,
			Self::ChunkData => ffi::ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA,
			Self::ExtendedChunkData => ffi::ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA,
			Self::Jpeg => ffi::ARV_BUFFER_PAYLOAD_TYPE_JPEG,
			Self::Jpeg2000 => ffi::ARV_BUFFER_PAYLOAD_TYPE_JPEG2000,
			Self::H264 => ffi::ARV_BUFFER_PAYLOAD_TYPE_H264,
			Self::MultizoneImage => ffi::ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE,
			Self::Multipart => ffi::ARV_BUFFER_PAYLOAD_TYPE_MULTIPART,
			Self::GendcContainer => ffi::ARV_BUFFER_PAYLOAD_TYPE_GENDC_CONTAINER,
			Self::GendcComponentData => ffi::ARV_BUFFER_PAYLOAD_TYPE_GENDC_COMPONENT_DATA,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvBufferPayloadType> for BufferPayloadType {
	unsafe fn from_glib(value: ffi::ArvBufferPayloadType) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_BUFFER_PAYLOAD_TYPE_UNKNOWN => Self::Unknown,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_NO_DATA => Self::NoData,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_IMAGE => Self::Image,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_RAWDATA => Self::Rawdata,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_FILE => Self::File,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_CHUNK_DATA => Self::ChunkData,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_EXTENDED_CHUNK_DATA => Self::ExtendedChunkData,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_JPEG => Self::Jpeg,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_JPEG2000 => Self::Jpeg2000,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_H264 => Self::H264,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_MULTIZONE_IMAGE => Self::MultizoneImage,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_MULTIPART => Self::Multipart,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_GENDC_CONTAINER => Self::GendcContainer,
			ffi::ARV_BUFFER_PAYLOAD_TYPE_GENDC_COMPONENT_DATA => Self::GendcComponentData,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for BufferPayloadType {
	#[inline]
	#[doc(alias = "arv_buffer_payload_type_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_buffer_payload_type_get_type()) }
	}
}

impl glib::HasParamSpec for BufferPayloadType {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for BufferPayloadType {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BufferPayloadType {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for BufferPayloadType {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<BufferPayloadType> for glib::Value {
	#[inline]
	fn from(v: BufferPayloadType) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvBufferStatus")]
pub enum BufferStatus {
	/// unknown status
	#[doc(alias = "ARV_BUFFER_STATUS_UNKNOWN")]
	Unknown,
	/// the buffer contains a valid image
	#[doc(alias = "ARV_BUFFER_STATUS_SUCCESS")]
	Success,
	/// the buffer is cleared
	#[doc(alias = "ARV_BUFFER_STATUS_CLEARED")]
	Cleared,
	/// timeout was reached before all packets are received
	#[doc(alias = "ARV_BUFFER_STATUS_TIMEOUT")]
	Timeout,
	/// stream has missing packets
	#[doc(alias = "ARV_BUFFER_STATUS_MISSING_PACKETS")]
	MissingPackets,
	/// stream has packet with wrong id
	#[doc(alias = "ARV_BUFFER_STATUS_WRONG_PACKET_ID")]
	WrongPacketId,
	/// the received image didn't fit in the buffer data space
	#[doc(alias = "ARV_BUFFER_STATUS_SIZE_MISMATCH")]
	SizeMismatch,
	/// the image is currently being filled
	#[doc(alias = "ARV_BUFFER_STATUS_FILLING")]
	Filling,
	/// the filling was aborted before completion
	#[doc(alias = "ARV_BUFFER_STATUS_ABORTED")]
	Aborted,
	/// payload not yet supported
	#[doc(alias = "ARV_BUFFER_STATUS_PAYLOAD_NOT_SUPPORTED")]
	PayloadNotSupported,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BufferStatus {
	type GlibType = ffi::ArvBufferStatus;

	#[inline]
	fn into_glib(self) -> ffi::ArvBufferStatus {
		match self {
			Self::Unknown => ffi::ARV_BUFFER_STATUS_UNKNOWN,
			Self::Success => ffi::ARV_BUFFER_STATUS_SUCCESS,
			Self::Cleared => ffi::ARV_BUFFER_STATUS_CLEARED,
			Self::Timeout => ffi::ARV_BUFFER_STATUS_TIMEOUT,
			Self::MissingPackets => ffi::ARV_BUFFER_STATUS_MISSING_PACKETS,
			Self::WrongPacketId => ffi::ARV_BUFFER_STATUS_WRONG_PACKET_ID,
			Self::SizeMismatch => ffi::ARV_BUFFER_STATUS_SIZE_MISMATCH,
			Self::Filling => ffi::ARV_BUFFER_STATUS_FILLING,
			Self::Aborted => ffi::ARV_BUFFER_STATUS_ABORTED,
			Self::PayloadNotSupported => ffi::ARV_BUFFER_STATUS_PAYLOAD_NOT_SUPPORTED,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvBufferStatus> for BufferStatus {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvBufferStatus) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_BUFFER_STATUS_UNKNOWN => Self::Unknown,
			ffi::ARV_BUFFER_STATUS_SUCCESS => Self::Success,
			ffi::ARV_BUFFER_STATUS_CLEARED => Self::Cleared,
			ffi::ARV_BUFFER_STATUS_TIMEOUT => Self::Timeout,
			ffi::ARV_BUFFER_STATUS_MISSING_PACKETS => Self::MissingPackets,
			ffi::ARV_BUFFER_STATUS_WRONG_PACKET_ID => Self::WrongPacketId,
			ffi::ARV_BUFFER_STATUS_SIZE_MISMATCH => Self::SizeMismatch,
			ffi::ARV_BUFFER_STATUS_FILLING => Self::Filling,
			ffi::ARV_BUFFER_STATUS_ABORTED => Self::Aborted,
			ffi::ARV_BUFFER_STATUS_PAYLOAD_NOT_SUPPORTED => Self::PayloadNotSupported,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for BufferStatus {
	#[inline]
	#[doc(alias = "arv_buffer_status_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_buffer_status_get_type()) }
	}
}

impl glib::HasParamSpec for BufferStatus {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for BufferStatus {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BufferStatus {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for BufferStatus {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<BufferStatus> for glib::Value {
	#[inline]
	fn from(v: BufferStatus) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvChunkParserError")]
pub enum ChunkParserError {
	/// invalid feature type
	#[doc(alias = "ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE")]
	InvalidFeatureType,
	/// a buffer is not attached to the chunk parser
	#[doc(alias = "ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND")]
	BufferNotFound,
	/// the requested chunk is not found in the buffer data
	#[doc(alias = "ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND")]
	ChunkNotFound,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ChunkParserError {
	type GlibType = ffi::ArvChunkParserError;

	#[inline]
	fn into_glib(self) -> ffi::ArvChunkParserError {
		match self {
			Self::InvalidFeatureType => ffi::ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE,
			Self::BufferNotFound => ffi::ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND,
			Self::ChunkNotFound => ffi::ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvChunkParserError> for ChunkParserError {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvChunkParserError) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_CHUNK_PARSER_ERROR_INVALID_FEATURE_TYPE => Self::InvalidFeatureType,
			ffi::ARV_CHUNK_PARSER_ERROR_BUFFER_NOT_FOUND => Self::BufferNotFound,
			ffi::ARV_CHUNK_PARSER_ERROR_CHUNK_NOT_FOUND => Self::ChunkNotFound,
			value => Self::__Unknown(value),
		}
	}
}

impl glib::error::ErrorDomain for ChunkParserError {
	#[inline]
	fn domain() -> glib::Quark {
		skip_assert_initialized!();

		unsafe { from_glib(ffi::arv_chunk_parser_error_quark()) }
	}

	#[inline]
	fn code(self) -> i32 {
		self.into_glib()
	}

	#[inline]
	#[allow(clippy::match_single_binding)]
	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match unsafe { from_glib(code) } {
			value => Some(value),
		}
	}
}

impl StaticType for ChunkParserError {
	#[inline]
	#[doc(alias = "arv_chunk_parser_error_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_chunk_parser_error_get_type()) }
	}
}

impl glib::HasParamSpec for ChunkParserError {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for ChunkParserError {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ChunkParserError {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for ChunkParserError {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<ChunkParserError> for glib::Value {
	#[inline]
	fn from(v: ChunkParserError) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvDeviceError")]
pub enum DeviceError {
	/// Wrong feature type
	#[doc(alias = "ARV_DEVICE_ERROR_WRONG_FEATURE")]
	WrongFeature,
	/// Feature node not found
	#[doc(alias = "ARV_DEVICE_ERROR_FEATURE_NOT_FOUND")]
	FeatureNotFound,
	/// Device is not connected
	#[doc(alias = "ARV_DEVICE_ERROR_NOT_CONNECTED")]
	NotConnected,
	/// Protocol error
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR")]
	ProtocolError,
	/// Transfer error
	#[doc(alias = "ARV_DEVICE_ERROR_TRANSFER_ERROR")]
	TransferError,
	/// Timeout detected
	#[doc(alias = "ARV_DEVICE_ERROR_TIMEOUT")]
	Timeout,
	/// Device not found
	#[doc(alias = "ARV_DEVICE_ERROR_NOT_FOUND")]
	NotFound,
	/// Invalid construction parameter
	#[doc(alias = "ARV_DEVICE_ERROR_INVALID_PARAMETER")]
	InvalidParameter,
	/// Missing Genicam data
	#[doc(alias = "ARV_DEVICE_ERROR_GENICAM_NOT_FOUND")]
	GenicamNotFound,
	/// No stream channel found
	#[doc(alias = "ARV_DEVICE_ERROR_NO_STREAM_CHANNEL")]
	NoStreamChannel,
	/// Controller privilege required
	#[doc(alias = "ARV_DEVICE_ERROR_NOT_CONTROLLER")]
	NotController,
	/// Unknown error
	#[doc(alias = "ARV_DEVICE_ERROR_UNKNOWN")]
	Unknown,
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR_NOT_IMPLEMENTED")]
	ProtocolErrorNotImplemented,
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_PARAMETER")]
	ProtocolErrorInvalidParameter,
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_ADDRESS")]
	ProtocolErrorInvalidAddress,
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR_WRITE_PROTECT")]
	ProtocolErrorWriteProtect,
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR_BAD_ALIGNMENT")]
	ProtocolErrorBadAlignment,
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR_ACCESS_DENIED")]
	ProtocolErrorAccessDenied,
	#[doc(alias = "ARV_DEVICE_ERROR_PROTOCOL_ERROR_BUSY")]
	ProtocolErrorBusy,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DeviceError {
	type GlibType = ffi::ArvDeviceError;

	fn into_glib(self) -> ffi::ArvDeviceError {
		match self {
			Self::WrongFeature => ffi::ARV_DEVICE_ERROR_WRONG_FEATURE,
			Self::FeatureNotFound => ffi::ARV_DEVICE_ERROR_FEATURE_NOT_FOUND,
			Self::NotConnected => ffi::ARV_DEVICE_ERROR_NOT_CONNECTED,
			Self::ProtocolError => ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR,
			Self::TransferError => ffi::ARV_DEVICE_ERROR_TRANSFER_ERROR,
			Self::Timeout => ffi::ARV_DEVICE_ERROR_TIMEOUT,
			Self::NotFound => ffi::ARV_DEVICE_ERROR_NOT_FOUND,
			Self::InvalidParameter => ffi::ARV_DEVICE_ERROR_INVALID_PARAMETER,
			Self::GenicamNotFound => ffi::ARV_DEVICE_ERROR_GENICAM_NOT_FOUND,
			Self::NoStreamChannel => ffi::ARV_DEVICE_ERROR_NO_STREAM_CHANNEL,
			Self::NotController => ffi::ARV_DEVICE_ERROR_NOT_CONTROLLER,
			Self::Unknown => ffi::ARV_DEVICE_ERROR_UNKNOWN,
			Self::ProtocolErrorNotImplemented => {
				ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_NOT_IMPLEMENTED
			}
			Self::ProtocolErrorInvalidParameter => {
				ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_PARAMETER
			}
			Self::ProtocolErrorInvalidAddress => {
				ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_ADDRESS
			}
			Self::ProtocolErrorWriteProtect => ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_WRITE_PROTECT,
			Self::ProtocolErrorBadAlignment => ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_BAD_ALIGNMENT,
			Self::ProtocolErrorAccessDenied => ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_ACCESS_DENIED,
			Self::ProtocolErrorBusy => ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_BUSY,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvDeviceError> for DeviceError {
	unsafe fn from_glib(value: ffi::ArvDeviceError) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_DEVICE_ERROR_WRONG_FEATURE => Self::WrongFeature,
			ffi::ARV_DEVICE_ERROR_FEATURE_NOT_FOUND => Self::FeatureNotFound,
			ffi::ARV_DEVICE_ERROR_NOT_CONNECTED => Self::NotConnected,
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR => Self::ProtocolError,
			ffi::ARV_DEVICE_ERROR_TRANSFER_ERROR => Self::TransferError,
			ffi::ARV_DEVICE_ERROR_TIMEOUT => Self::Timeout,
			ffi::ARV_DEVICE_ERROR_NOT_FOUND => Self::NotFound,
			ffi::ARV_DEVICE_ERROR_INVALID_PARAMETER => Self::InvalidParameter,
			ffi::ARV_DEVICE_ERROR_GENICAM_NOT_FOUND => Self::GenicamNotFound,
			ffi::ARV_DEVICE_ERROR_NO_STREAM_CHANNEL => Self::NoStreamChannel,
			ffi::ARV_DEVICE_ERROR_NOT_CONTROLLER => Self::NotController,
			ffi::ARV_DEVICE_ERROR_UNKNOWN => Self::Unknown,
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_NOT_IMPLEMENTED => {
				Self::ProtocolErrorNotImplemented
			}
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_PARAMETER => {
				Self::ProtocolErrorInvalidParameter
			}
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_INVALID_ADDRESS => {
				Self::ProtocolErrorInvalidAddress
			}
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_WRITE_PROTECT => Self::ProtocolErrorWriteProtect,
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_BAD_ALIGNMENT => Self::ProtocolErrorBadAlignment,
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_ACCESS_DENIED => Self::ProtocolErrorAccessDenied,
			ffi::ARV_DEVICE_ERROR_PROTOCOL_ERROR_BUSY => Self::ProtocolErrorBusy,
			value => Self::__Unknown(value),
		}
	}
}

impl glib::error::ErrorDomain for DeviceError {
	#[inline]
	fn domain() -> glib::Quark {
		skip_assert_initialized!();

		unsafe { from_glib(ffi::arv_device_error_quark()) }
	}

	#[inline]
	fn code(self) -> i32 {
		self.into_glib()
	}

	#[inline]
	#[allow(clippy::match_single_binding)]
	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match unsafe { from_glib(code) } {
			value => Some(value),
		}
	}
}

impl StaticType for DeviceError {
	#[inline]
	#[doc(alias = "arv_device_error_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_device_error_get_type()) }
	}
}

impl glib::HasParamSpec for DeviceError {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for DeviceError {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DeviceError {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for DeviceError {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<DeviceError> for glib::Value {
	#[inline]
	fn from(v: DeviceError) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvDomNodeType")]
pub enum DomNodeType {
	#[doc(alias = "ARV_DOM_NODE_TYPE_ELEMENT_NODE")]
	ElementNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE")]
	AttributeNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_TEXT_NODE")]
	TextNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE")]
	CdataSectionNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE")]
	EntityReferenceNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_ENTITY_NODE")]
	EntityNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE")]
	ProcessingInstructionNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_COMMENT_NODE")]
	CommentNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_DOCUMENT_NODE")]
	DocumentNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE")]
	DocumentTypeNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE")]
	DocumentFragmentNode,
	#[doc(alias = "ARV_DOM_NODE_TYPE_NOTATION_NODE")]
	NotationNode,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DomNodeType {
	type GlibType = ffi::ArvDomNodeType;

	#[inline]
	fn into_glib(self) -> ffi::ArvDomNodeType {
		match self {
			Self::ElementNode => ffi::ARV_DOM_NODE_TYPE_ELEMENT_NODE,
			Self::AttributeNode => ffi::ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE,
			Self::TextNode => ffi::ARV_DOM_NODE_TYPE_TEXT_NODE,
			Self::CdataSectionNode => ffi::ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE,
			Self::EntityReferenceNode => ffi::ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE,
			Self::EntityNode => ffi::ARV_DOM_NODE_TYPE_ENTITY_NODE,
			Self::ProcessingInstructionNode => ffi::ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE,
			Self::CommentNode => ffi::ARV_DOM_NODE_TYPE_COMMENT_NODE,
			Self::DocumentNode => ffi::ARV_DOM_NODE_TYPE_DOCUMENT_NODE,
			Self::DocumentTypeNode => ffi::ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE,
			Self::DocumentFragmentNode => ffi::ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE,
			Self::NotationNode => ffi::ARV_DOM_NODE_TYPE_NOTATION_NODE,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvDomNodeType> for DomNodeType {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvDomNodeType) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_DOM_NODE_TYPE_ELEMENT_NODE => Self::ElementNode,
			ffi::ARV_DOM_NODE_TYPE_ATTRIBUTE_NODE => Self::AttributeNode,
			ffi::ARV_DOM_NODE_TYPE_TEXT_NODE => Self::TextNode,
			ffi::ARV_DOM_NODE_TYPE_CDATA_SECTION_NODE => Self::CdataSectionNode,
			ffi::ARV_DOM_NODE_TYPE_ENTITY_REFERENCE_NODE => Self::EntityReferenceNode,
			ffi::ARV_DOM_NODE_TYPE_ENTITY_NODE => Self::EntityNode,
			ffi::ARV_DOM_NODE_TYPE_PROCESSING_INSTRUCTION_NODE => Self::ProcessingInstructionNode,
			ffi::ARV_DOM_NODE_TYPE_COMMENT_NODE => Self::CommentNode,
			ffi::ARV_DOM_NODE_TYPE_DOCUMENT_NODE => Self::DocumentNode,
			ffi::ARV_DOM_NODE_TYPE_DOCUMENT_TYPE_NODE => Self::DocumentTypeNode,
			ffi::ARV_DOM_NODE_TYPE_DOCUMENT_FRAGMENT_NODE => Self::DocumentFragmentNode,
			ffi::ARV_DOM_NODE_TYPE_NOTATION_NODE => Self::NotationNode,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for DomNodeType {
	#[inline]
	#[doc(alias = "arv_dom_node_type_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_dom_node_type_get_type()) }
	}
}

impl glib::HasParamSpec for DomNodeType {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for DomNodeType {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DomNodeType {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for DomNodeType {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<DomNodeType> for glib::Value {
	#[inline]
	fn from(v: DomNodeType) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvExposureMode")]
pub enum ExposureMode {
	/// disables the Exposure and let the shutter open.
	#[doc(alias = "ARV_EXPOSURE_MODE_OFF")]
	Off,
	/// timed exposure. The exposure duration time is set using the ExposureTime or ExposureAuto
	/// features and the exposure starts with the FrameStart or LineStart.
	#[doc(alias = "ARV_EXPOSURE_MODE_TIMED")]
	Timed,
	/// uses the width of the current Frame or Line trigger signal(s) pulse to control the
	/// exposure duration. Note that if the Frame or Line TriggerActivation is RisingEdge or LevelHigh, the exposure duration
	/// will be the time the trigger stays High. If TriggerActivation is FallingEdge or LevelLow, the exposure time will last
	/// as long as the trigger stays Low.
	#[doc(alias = "ARV_EXPOSURE_MODE_TRIGGER_WIDTH")]
	TriggerWidth,
	/// uses one or more trigger signal(s) to control the exposure duration
	/// independently from the current Frame or Line triggers. See ExposureStart, ExposureEnd and ExposureActive of
	/// the TriggerSelector feature.
	#[doc(alias = "ARV_EXPOSURE_MODE_TRIGGER_CONTROLLED")]
	TriggerControlled,
	#[doc(hidden)]
	__Unknown(i32),
}

impl ExposureMode {
	#[doc(alias = "arv_exposure_mode_from_string")]
	pub fn from_string(string: &str) -> ExposureMode {
		assert_initialized_main_thread!();
		unsafe { from_glib(ffi::arv_exposure_mode_from_string(string.to_glib_none().0)) }
	}

	#[doc(alias = "arv_exposure_mode_to_string")]
	#[doc(alias = "to_string")]
	pub fn to_str(self) -> Option<glib::GString> {
		assert_initialized_main_thread!();
		unsafe { from_glib_none(ffi::arv_exposure_mode_to_string(self.into_glib())) }
	}
}

#[doc(hidden)]
impl IntoGlib for ExposureMode {
	type GlibType = ffi::ArvExposureMode;

	#[inline]
	fn into_glib(self) -> ffi::ArvExposureMode {
		match self {
			Self::Off => ffi::ARV_EXPOSURE_MODE_OFF,
			Self::Timed => ffi::ARV_EXPOSURE_MODE_TIMED,
			Self::TriggerWidth => ffi::ARV_EXPOSURE_MODE_TRIGGER_WIDTH,
			Self::TriggerControlled => ffi::ARV_EXPOSURE_MODE_TRIGGER_CONTROLLED,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvExposureMode> for ExposureMode {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvExposureMode) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_EXPOSURE_MODE_OFF => Self::Off,
			ffi::ARV_EXPOSURE_MODE_TIMED => Self::Timed,
			ffi::ARV_EXPOSURE_MODE_TRIGGER_WIDTH => Self::TriggerWidth,
			ffi::ARV_EXPOSURE_MODE_TRIGGER_CONTROLLED => Self::TriggerControlled,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for ExposureMode {
	#[inline]
	#[doc(alias = "arv_exposure_mode_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_exposure_mode_get_type()) }
	}
}

impl glib::HasParamSpec for ExposureMode {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for ExposureMode {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ExposureMode {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for ExposureMode {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<ExposureMode> for glib::Value {
	#[inline]
	fn from(v: ExposureMode) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Specifies access mode for feature nodes and registers.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcAccessMode")]
pub enum GcAccessMode {
	/// undefined access mode
	#[doc(alias = "ARV_GC_ACCESS_MODE_UNDEFINED")]
	Undefined,
	/// read-only access
	#[doc(alias = "ARV_GC_ACCESS_MODE_RO")]
	Ro,
	/// write-only access
	#[doc(alias = "ARV_GC_ACCESS_MODE_WO")]
	Wo,
	/// read and write access
	#[doc(alias = "ARV_GC_ACCESS_MODE_RW")]
	Rw,
	#[doc(hidden)]
	__Unknown(i32),
}

impl GcAccessMode {
	#[doc(alias = "arv_gc_access_mode_from_string")]
	pub fn from_string(string: &str) -> GcAccessMode {
		assert_initialized_main_thread!();
		unsafe { from_glib(ffi::arv_gc_access_mode_from_string(string.to_glib_none().0)) }
	}

	#[doc(alias = "arv_gc_access_mode_to_string")]
	#[doc(alias = "to_string")]
	pub fn to_str(self) -> Option<glib::GString> {
		assert_initialized_main_thread!();
		unsafe { from_glib_none(ffi::arv_gc_access_mode_to_string(self.into_glib())) }
	}
}

#[doc(hidden)]
impl IntoGlib for GcAccessMode {
	type GlibType = ffi::ArvGcAccessMode;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcAccessMode {
		match self {
			Self::Undefined => ffi::ARV_GC_ACCESS_MODE_UNDEFINED,
			Self::Ro => ffi::ARV_GC_ACCESS_MODE_RO,
			Self::Wo => ffi::ARV_GC_ACCESS_MODE_WO,
			Self::Rw => ffi::ARV_GC_ACCESS_MODE_RW,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcAccessMode> for GcAccessMode {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcAccessMode) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_ACCESS_MODE_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_ACCESS_MODE_RO => Self::Ro,
			ffi::ARV_GC_ACCESS_MODE_WO => Self::Wo,
			ffi::ARV_GC_ACCESS_MODE_RW => Self::Rw,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcAccessMode {
	#[inline]
	#[doc(alias = "arv_gc_access_mode_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_access_mode_get_type()) }
	}
}

impl glib::HasParamSpec for GcAccessMode {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcAccessMode {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcAccessMode {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcAccessMode {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcAccessMode> for glib::Value {
	#[inline]
	fn from(v: GcAccessMode) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Specifies caching mode for register values.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcCachable")]
pub enum GcCachable {
	/// undefined cache mode
	#[doc(alias = "ARV_GC_CACHABLE_UNDEFINED")]
	Undefined,
	/// no value caching
	#[doc(alias = "ARV_GC_CACHABLE_NO_CACHE")]
	NoCache,
	/// write-through cache mode
	#[doc(alias = "ARV_GC_CACHABLE_WRITE_THROUGH")]
	WriteThrough,
	/// write-around cache mode
	#[doc(alias = "ARV_GC_CACHABLE_WRITE_AROUND")]
	WriteAround,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcCachable {
	type GlibType = ffi::ArvGcCachable;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcCachable {
		match self {
			Self::Undefined => ffi::ARV_GC_CACHABLE_UNDEFINED,
			Self::NoCache => ffi::ARV_GC_CACHABLE_NO_CACHE,
			Self::WriteThrough => ffi::ARV_GC_CACHABLE_WRITE_THROUGH,
			Self::WriteAround => ffi::ARV_GC_CACHABLE_WRITE_AROUND,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcCachable> for GcCachable {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcCachable) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_CACHABLE_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_CACHABLE_NO_CACHE => Self::NoCache,
			ffi::ARV_GC_CACHABLE_WRITE_THROUGH => Self::WriteThrough,
			ffi::ARV_GC_CACHABLE_WRITE_AROUND => Self::WriteAround,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcCachable {
	#[inline]
	#[doc(alias = "arv_gc_cachable_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_cachable_get_type()) }
	}
}

impl glib::HasParamSpec for GcCachable {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcCachable {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcCachable {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcCachable {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcCachable> for glib::Value {
	#[inline]
	fn from(v: GcCachable) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Number display notations for showing numbers in user interfaces.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcDisplayNotation")]
pub enum GcDisplayNotation {
	/// undefined number notation
	#[doc(alias = "ARV_GC_DISPLAY_NOTATION_UNDEFINED")]
	Undefined,
	/// automatically detect whether to use fixed or scientific number notation
	#[doc(alias = "ARV_GC_DISPLAY_NOTATION_AUTOMATIC")]
	Automatic,
	/// used fixed (i.e. decimal) notation for displaying numbers
	#[doc(alias = "ARV_GC_DISPLAY_NOTATION_FIXED")]
	Fixed,
	/// use scientific notation for displaying numbers
	#[doc(alias = "ARV_GC_DISPLAY_NOTATION_SCIENTIFIC")]
	Scientific,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcDisplayNotation {
	type GlibType = ffi::ArvGcDisplayNotation;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcDisplayNotation {
		match self {
			Self::Undefined => ffi::ARV_GC_DISPLAY_NOTATION_UNDEFINED,
			Self::Automatic => ffi::ARV_GC_DISPLAY_NOTATION_AUTOMATIC,
			Self::Fixed => ffi::ARV_GC_DISPLAY_NOTATION_FIXED,
			Self::Scientific => ffi::ARV_GC_DISPLAY_NOTATION_SCIENTIFIC,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcDisplayNotation> for GcDisplayNotation {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcDisplayNotation) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_DISPLAY_NOTATION_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_DISPLAY_NOTATION_AUTOMATIC => Self::Automatic,
			ffi::ARV_GC_DISPLAY_NOTATION_FIXED => Self::Fixed,
			ffi::ARV_GC_DISPLAY_NOTATION_SCIENTIFIC => Self::Scientific,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcDisplayNotation {
	#[inline]
	#[doc(alias = "arv_gc_display_notation_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_display_notation_get_type()) }
	}
}

impl glib::HasParamSpec for GcDisplayNotation {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcDisplayNotation {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcDisplayNotation {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcDisplayNotation {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcDisplayNotation> for glib::Value {
	#[inline]
	fn from(v: GcDisplayNotation) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcError")]
pub enum GcError {
	#[doc(alias = "ARV_GC_ERROR_PROPERTY_NOT_DEFINED")]
	PropertyNotDefined,
	#[doc(alias = "ARV_GC_ERROR_PVALUE_NOT_DEFINED")]
	PvalueNotDefined,
	#[doc(alias = "ARV_GC_ERROR_INVALID_PVALUE")]
	InvalidPvalue,
	#[doc(alias = "ARV_GC_ERROR_EMPTY_ENUMERATION")]
	EmptyEnumeration,
	#[doc(alias = "ARV_GC_ERROR_OUT_OF_RANGE")]
	OutOfRange,
	#[doc(alias = "ARV_GC_ERROR_NO_DEVICE_SET")]
	NoDeviceSet,
	#[doc(alias = "ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION")]
	NoEventImplementation,
	#[doc(alias = "ARV_GC_ERROR_NODE_NOT_FOUND")]
	NodeNotFound,
	#[doc(alias = "ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND")]
	EnumEntryNotFound,
	#[doc(alias = "ARV_GC_ERROR_INVALID_LENGTH")]
	InvalidLength,
	#[doc(alias = "ARV_GC_ERROR_READ_ONLY")]
	ReadOnly,
	#[doc(alias = "ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED")]
	SetFromStringUndefined,
	#[doc(alias = "ARV_GC_ERROR_GET_AS_STRING_UNDEFINED")]
	GetAsStringUndefined,
	#[doc(alias = "ARV_GC_ERROR_INVALID_BIT_RANGE")]
	InvalidBitRange,
	#[doc(alias = "ARV_GC_ERROR_INVALID_SYNTAX")]
	InvalidSyntax,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcError {
	type GlibType = ffi::ArvGcError;

	fn into_glib(self) -> ffi::ArvGcError {
		match self {
			Self::PropertyNotDefined => ffi::ARV_GC_ERROR_PROPERTY_NOT_DEFINED,
			Self::PvalueNotDefined => ffi::ARV_GC_ERROR_PVALUE_NOT_DEFINED,
			Self::InvalidPvalue => ffi::ARV_GC_ERROR_INVALID_PVALUE,
			Self::EmptyEnumeration => ffi::ARV_GC_ERROR_EMPTY_ENUMERATION,
			Self::OutOfRange => ffi::ARV_GC_ERROR_OUT_OF_RANGE,
			Self::NoDeviceSet => ffi::ARV_GC_ERROR_NO_DEVICE_SET,
			Self::NoEventImplementation => ffi::ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION,
			Self::NodeNotFound => ffi::ARV_GC_ERROR_NODE_NOT_FOUND,
			Self::EnumEntryNotFound => ffi::ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND,
			Self::InvalidLength => ffi::ARV_GC_ERROR_INVALID_LENGTH,
			Self::ReadOnly => ffi::ARV_GC_ERROR_READ_ONLY,
			Self::SetFromStringUndefined => ffi::ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED,
			Self::GetAsStringUndefined => ffi::ARV_GC_ERROR_GET_AS_STRING_UNDEFINED,
			Self::InvalidBitRange => ffi::ARV_GC_ERROR_INVALID_BIT_RANGE,
			Self::InvalidSyntax => ffi::ARV_GC_ERROR_INVALID_SYNTAX,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcError> for GcError {
	unsafe fn from_glib(value: ffi::ArvGcError) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_ERROR_PROPERTY_NOT_DEFINED => Self::PropertyNotDefined,
			ffi::ARV_GC_ERROR_PVALUE_NOT_DEFINED => Self::PvalueNotDefined,
			ffi::ARV_GC_ERROR_INVALID_PVALUE => Self::InvalidPvalue,
			ffi::ARV_GC_ERROR_EMPTY_ENUMERATION => Self::EmptyEnumeration,
			ffi::ARV_GC_ERROR_OUT_OF_RANGE => Self::OutOfRange,
			ffi::ARV_GC_ERROR_NO_DEVICE_SET => Self::NoDeviceSet,
			ffi::ARV_GC_ERROR_NO_EVENT_IMPLEMENTATION => Self::NoEventImplementation,
			ffi::ARV_GC_ERROR_NODE_NOT_FOUND => Self::NodeNotFound,
			ffi::ARV_GC_ERROR_ENUM_ENTRY_NOT_FOUND => Self::EnumEntryNotFound,
			ffi::ARV_GC_ERROR_INVALID_LENGTH => Self::InvalidLength,
			ffi::ARV_GC_ERROR_READ_ONLY => Self::ReadOnly,
			ffi::ARV_GC_ERROR_SET_FROM_STRING_UNDEFINED => Self::SetFromStringUndefined,
			ffi::ARV_GC_ERROR_GET_AS_STRING_UNDEFINED => Self::GetAsStringUndefined,
			ffi::ARV_GC_ERROR_INVALID_BIT_RANGE => Self::InvalidBitRange,
			ffi::ARV_GC_ERROR_INVALID_SYNTAX => Self::InvalidSyntax,
			value => Self::__Unknown(value),
		}
	}
}

impl glib::error::ErrorDomain for GcError {
	#[inline]
	fn domain() -> glib::Quark {
		skip_assert_initialized!();

		unsafe { from_glib(ffi::arv_gc_error_quark()) }
	}

	#[inline]
	fn code(self) -> i32 {
		self.into_glib()
	}

	#[inline]
	#[allow(clippy::match_single_binding)]
	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match unsafe { from_glib(code) } {
			value => Some(value),
		}
	}
}

impl StaticType for GcError {
	#[inline]
	#[doc(alias = "arv_gc_error_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_error_get_type()) }
	}
}

impl glib::HasParamSpec for GcError {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcError {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcError {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcError {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcError> for glib::Value {
	#[inline]
	fn from(v: GcError) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Describes relationship between TO and FROM variables in Converter feature nodes.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcIsLinear")]
pub enum GcIsLinear {
	/// undefined relationship between variables
	#[doc(alias = "ARV_GC_IS_LINEAR_UNDEFINED")]
	Undefined,
	/// non-linear relationship between variables
	#[doc(alias = "ARV_GC_IS_LINEAR_NO")]
	No,
	/// linear relationship between variables
	#[doc(alias = "ARV_GC_IS_LINEAR_YES")]
	Yes,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcIsLinear {
	type GlibType = ffi::ArvGcIsLinear;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcIsLinear {
		match self {
			Self::Undefined => ffi::ARV_GC_IS_LINEAR_UNDEFINED,
			Self::No => ffi::ARV_GC_IS_LINEAR_NO,
			Self::Yes => ffi::ARV_GC_IS_LINEAR_YES,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcIsLinear> for GcIsLinear {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcIsLinear) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_IS_LINEAR_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_IS_LINEAR_NO => Self::No,
			ffi::ARV_GC_IS_LINEAR_YES => Self::Yes,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcIsLinear {
	#[inline]
	#[doc(alias = "arv_gc_is_linear_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_is_linear_get_type()) }
	}
}

impl glib::HasParamSpec for GcIsLinear {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcIsLinear {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcIsLinear {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcIsLinear {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcIsLinear> for glib::Value {
	#[inline]
	fn from(v: GcIsLinear) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Specifies feature node or register name space type. Standard name space features are listed in
/// Genicam materials. Any other vendor-specific features should use custom name space type.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcNameSpace")]
pub enum GcNameSpace {
	/// undefined name space
	#[doc(alias = "ARV_GC_NAME_SPACE_UNDEFINED")]
	Undefined,
	/// Genicam standardized name space
	#[doc(alias = "ARV_GC_NAME_SPACE_STANDARD")]
	Standard,
	/// non-standardized name space
	#[doc(alias = "ARV_GC_NAME_SPACE_CUSTOM")]
	Custom,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcNameSpace {
	type GlibType = ffi::ArvGcNameSpace;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcNameSpace {
		match self {
			Self::Undefined => ffi::ARV_GC_NAME_SPACE_UNDEFINED,
			Self::Standard => ffi::ARV_GC_NAME_SPACE_STANDARD,
			Self::Custom => ffi::ARV_GC_NAME_SPACE_CUSTOM,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcNameSpace> for GcNameSpace {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcNameSpace) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_NAME_SPACE_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_NAME_SPACE_STANDARD => Self::Standard,
			ffi::ARV_GC_NAME_SPACE_CUSTOM => Self::Custom,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcNameSpace {
	#[inline]
	#[doc(alias = "arv_gc_name_space_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_name_space_get_type()) }
	}
}

impl glib::HasParamSpec for GcNameSpace {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcNameSpace {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcNameSpace {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcNameSpace {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcNameSpace> for glib::Value {
	#[inline]
	fn from(v: GcNameSpace) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcPropertyNodeType")]
pub enum GcPropertyNodeType {
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN")]
	Unknown,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_VALUE")]
	Value,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_ADDRESS")]
	Address,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION")]
	Description,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY")]
	Visibility,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP")]
	Tooltip,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME")]
	DisplayName,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_MINIMUM")]
	Minimum,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM")]
	Maximum,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_SLOPE")]
	Slope,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_INCREMENT")]
	Increment,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR")]
	IsLinear,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION")]
	Representation,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION")]
	DisplayNotation,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION")]
	DisplayPrecision,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_UNIT")]
	Unit,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE")]
	OnValue,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE")]
	OffValue,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_LENGTH")]
	Length,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_FORMULA")]
	Formula,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO")]
	FormulaTo,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM")]
	FormulaFrom,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION")]
	Expression,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_CONSTANT")]
	Constant,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE")]
	AccessMode,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE")]
	ImposedAccessMode,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_CACHABLE")]
	Cachable,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME")]
	PollingTime,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS")]
	Endianness,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_SIGN")]
	Sign,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_LSB")]
	Lsb,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_MSB")]
	Msb,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_BIT")]
	Bit,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE")]
	CommandValue,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID")]
	ChunkId,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID")]
	EventId,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED")]
	ValueIndexed,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT")]
	ValueDefault,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_STREAMABLE")]
	Streamable,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_IS_DEPRECATED")]
	IsDeprecated,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW")]
	PUnknonw,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE")]
	PFeature,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_VALUE")]
	PValue,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS")]
	PAddress,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED")]
	PIsImplemented,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED")]
	PIsLocked,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE")]
	PIsAvailable,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED")]
	PSelected,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM")]
	PMinimum,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM")]
	PMaximum,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT")]
	PIncrement,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_INDEX")]
	PIndex,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH")]
	PLength,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_PORT")]
	PPort,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE")]
	PVariable,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR")]
	PInvalidator,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE")]
	PCommandValue,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED")]
	PValueIndexed,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT")]
	PValueDefault,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_ALIAS")]
	PAlias,
	#[doc(alias = "ARV_GC_PROPERTY_NODE_TYPE_P_CAST_ALIAS")]
	PCastAlias,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcPropertyNodeType {
	type GlibType = ffi::ArvGcPropertyNodeType;

	fn into_glib(self) -> ffi::ArvGcPropertyNodeType {
		match self {
			Self::Unknown => ffi::ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN,
			Self::Value => ffi::ARV_GC_PROPERTY_NODE_TYPE_VALUE,
			Self::Address => ffi::ARV_GC_PROPERTY_NODE_TYPE_ADDRESS,
			Self::Description => ffi::ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION,
			Self::Visibility => ffi::ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY,
			Self::Tooltip => ffi::ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP,
			Self::DisplayName => ffi::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME,
			Self::Minimum => ffi::ARV_GC_PROPERTY_NODE_TYPE_MINIMUM,
			Self::Maximum => ffi::ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM,
			Self::Slope => ffi::ARV_GC_PROPERTY_NODE_TYPE_SLOPE,
			Self::Increment => ffi::ARV_GC_PROPERTY_NODE_TYPE_INCREMENT,
			Self::IsLinear => ffi::ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR,
			Self::Representation => ffi::ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION,
			Self::DisplayNotation => ffi::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION,
			Self::DisplayPrecision => ffi::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION,
			Self::Unit => ffi::ARV_GC_PROPERTY_NODE_TYPE_UNIT,
			Self::OnValue => ffi::ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE,
			Self::OffValue => ffi::ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE,
			Self::Length => ffi::ARV_GC_PROPERTY_NODE_TYPE_LENGTH,
			Self::Formula => ffi::ARV_GC_PROPERTY_NODE_TYPE_FORMULA,
			Self::FormulaTo => ffi::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO,
			Self::FormulaFrom => ffi::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM,
			Self::Expression => ffi::ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION,
			Self::Constant => ffi::ARV_GC_PROPERTY_NODE_TYPE_CONSTANT,
			Self::AccessMode => ffi::ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE,
			Self::ImposedAccessMode => ffi::ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE,
			Self::Cachable => ffi::ARV_GC_PROPERTY_NODE_TYPE_CACHABLE,
			Self::PollingTime => ffi::ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME,
			Self::Endianness => ffi::ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS,
			Self::Sign => ffi::ARV_GC_PROPERTY_NODE_TYPE_SIGN,
			Self::Lsb => ffi::ARV_GC_PROPERTY_NODE_TYPE_LSB,
			Self::Msb => ffi::ARV_GC_PROPERTY_NODE_TYPE_MSB,
			Self::Bit => ffi::ARV_GC_PROPERTY_NODE_TYPE_BIT,
			Self::CommandValue => ffi::ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE,
			Self::ChunkId => ffi::ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID,
			Self::EventId => ffi::ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID,
			Self::ValueIndexed => ffi::ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED,
			Self::ValueDefault => ffi::ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT,
			Self::Streamable => ffi::ARV_GC_PROPERTY_NODE_TYPE_STREAMABLE,
			Self::IsDeprecated => ffi::ARV_GC_PROPERTY_NODE_TYPE_IS_DEPRECATED,
			Self::PUnknonw => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW,
			Self::PFeature => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE,
			Self::PValue => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE,
			Self::PAddress => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS,
			Self::PIsImplemented => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED,
			Self::PIsLocked => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED,
			Self::PIsAvailable => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE,
			Self::PSelected => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED,
			Self::PMinimum => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM,
			Self::PMaximum => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM,
			Self::PIncrement => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT,
			Self::PIndex => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_INDEX,
			Self::PLength => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH,
			Self::PPort => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_PORT,
			Self::PVariable => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE,
			Self::PInvalidator => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR,
			Self::PCommandValue => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE,
			Self::PValueIndexed => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED,
			Self::PValueDefault => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT,
			Self::PAlias => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_ALIAS,
			Self::PCastAlias => ffi::ARV_GC_PROPERTY_NODE_TYPE_P_CAST_ALIAS,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcPropertyNodeType> for GcPropertyNodeType {
	unsafe fn from_glib(value: ffi::ArvGcPropertyNodeType) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_PROPERTY_NODE_TYPE_UNKNOWN => Self::Unknown,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_VALUE => Self::Value,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_ADDRESS => Self::Address,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_DESCRIPTION => Self::Description,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_VISIBILITY => Self::Visibility,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_TOOLTIP => Self::Tooltip,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NAME => Self::DisplayName,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_MINIMUM => Self::Minimum,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_MAXIMUM => Self::Maximum,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_SLOPE => Self::Slope,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_INCREMENT => Self::Increment,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_IS_LINEAR => Self::IsLinear,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_REPRESENTATION => Self::Representation,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_NOTATION => Self::DisplayNotation,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_DISPLAY_PRECISION => Self::DisplayPrecision,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_UNIT => Self::Unit,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_ON_VALUE => Self::OnValue,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_OFF_VALUE => Self::OffValue,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_LENGTH => Self::Length,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_FORMULA => Self::Formula,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_TO => Self::FormulaTo,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_FORMULA_FROM => Self::FormulaFrom,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_EXPRESSION => Self::Expression,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_CONSTANT => Self::Constant,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_ACCESS_MODE => Self::AccessMode,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_IMPOSED_ACCESS_MODE => Self::ImposedAccessMode,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_CACHABLE => Self::Cachable,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_POLLING_TIME => Self::PollingTime,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_ENDIANNESS => Self::Endianness,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_SIGN => Self::Sign,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_LSB => Self::Lsb,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_MSB => Self::Msb,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_BIT => Self::Bit,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_COMMAND_VALUE => Self::CommandValue,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_CHUNK_ID => Self::ChunkId,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_EVENT_ID => Self::EventId,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_VALUE_INDEXED => Self::ValueIndexed,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_VALUE_DEFAULT => Self::ValueDefault,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_STREAMABLE => Self::Streamable,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_IS_DEPRECATED => Self::IsDeprecated,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_UNKNONW => Self::PUnknonw,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_FEATURE => Self::PFeature,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE => Self::PValue,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_ADDRESS => Self::PAddress,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_IS_IMPLEMENTED => Self::PIsImplemented,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_IS_LOCKED => Self::PIsLocked,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_IS_AVAILABLE => Self::PIsAvailable,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_SELECTED => Self::PSelected,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_MINIMUM => Self::PMinimum,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_MAXIMUM => Self::PMaximum,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_INCREMENT => Self::PIncrement,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_INDEX => Self::PIndex,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_LENGTH => Self::PLength,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_PORT => Self::PPort,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VARIABLE => Self::PVariable,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_INVALIDATOR => Self::PInvalidator,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_COMMAND_VALUE => Self::PCommandValue,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_INDEXED => Self::PValueIndexed,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_VALUE_DEFAULT => Self::PValueDefault,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_ALIAS => Self::PAlias,
			ffi::ARV_GC_PROPERTY_NODE_TYPE_P_CAST_ALIAS => Self::PCastAlias,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcPropertyNodeType {
	#[inline]
	#[doc(alias = "arv_gc_property_node_type_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_property_node_type_get_type()) }
	}
}

impl glib::HasParamSpec for GcPropertyNodeType {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcPropertyNodeType {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcPropertyNodeType {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcPropertyNodeType {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcPropertyNodeType> for glib::Value {
	#[inline]
	fn from(v: GcPropertyNodeType) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Number representation formats.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcRepresentation")]
pub enum GcRepresentation {
	/// undefined representation
	#[doc(alias = "ARV_GC_REPRESENTATION_UNDEFINED")]
	Undefined,
	/// number presented on linear scale (e.g. on a linear slider)
	#[doc(alias = "ARV_GC_REPRESENTATION_LINEAR")]
	Linear,
	/// number presented on logarithmic scale (e.g. on a logarithmic slider)
	#[doc(alias = "ARV_GC_REPRESENTATION_LOGARITHMIC")]
	Logarithmic,
	/// binary choice (e.g. a checkbox)
	#[doc(alias = "ARV_GC_REPRESENTATION_BOOLEAN")]
	Boolean,
	/// number presented in an editable field (e.g. a spinbox)
	#[doc(alias = "ARV_GC_REPRESENTATION_PURE_NUMBER")]
	PureNumber,
	/// number presented in hexadecimal format
	#[doc(alias = "ARV_GC_REPRESENTATION_HEX_NUMBER")]
	HexNumber,
	/// IPv4 address
	#[doc(alias = "ARV_GC_REPRESENTATION_IPV4_ADDRESS")]
	Ipv4Address,
	/// MAC address
	#[doc(alias = "ARV_GC_REPRESENTATION_MAC_ADDRESS")]
	MacAddress,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcRepresentation {
	type GlibType = ffi::ArvGcRepresentation;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcRepresentation {
		match self {
			Self::Undefined => ffi::ARV_GC_REPRESENTATION_UNDEFINED,
			Self::Linear => ffi::ARV_GC_REPRESENTATION_LINEAR,
			Self::Logarithmic => ffi::ARV_GC_REPRESENTATION_LOGARITHMIC,
			Self::Boolean => ffi::ARV_GC_REPRESENTATION_BOOLEAN,
			Self::PureNumber => ffi::ARV_GC_REPRESENTATION_PURE_NUMBER,
			Self::HexNumber => ffi::ARV_GC_REPRESENTATION_HEX_NUMBER,
			Self::Ipv4Address => ffi::ARV_GC_REPRESENTATION_IPV4_ADDRESS,
			Self::MacAddress => ffi::ARV_GC_REPRESENTATION_MAC_ADDRESS,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcRepresentation> for GcRepresentation {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcRepresentation) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_REPRESENTATION_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_REPRESENTATION_LINEAR => Self::Linear,
			ffi::ARV_GC_REPRESENTATION_LOGARITHMIC => Self::Logarithmic,
			ffi::ARV_GC_REPRESENTATION_BOOLEAN => Self::Boolean,
			ffi::ARV_GC_REPRESENTATION_PURE_NUMBER => Self::PureNumber,
			ffi::ARV_GC_REPRESENTATION_HEX_NUMBER => Self::HexNumber,
			ffi::ARV_GC_REPRESENTATION_IPV4_ADDRESS => Self::Ipv4Address,
			ffi::ARV_GC_REPRESENTATION_MAC_ADDRESS => Self::MacAddress,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcRepresentation {
	#[inline]
	#[doc(alias = "arv_gc_representation_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_representation_get_type()) }
	}
}

impl glib::HasParamSpec for GcRepresentation {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcRepresentation {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcRepresentation {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcRepresentation {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcRepresentation> for glib::Value {
	#[inline]
	fn from(v: GcRepresentation) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Specifies signedness of integer registers. Per standard Genicam internally uses signed 64-bit
/// signed integers for representing all integer registers. Therefore unsigned 64-bit integers are
/// not available.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcSignedness")]
pub enum GcSignedness {
	/// undefined sign
	#[doc(alias = "ARV_GC_SIGNEDNESS_UNDEFINED")]
	Undefined,
	/// signed integer
	#[doc(alias = "ARV_GC_SIGNEDNESS_SIGNED")]
	Signed,
	/// unsigned integer
	#[doc(alias = "ARV_GC_SIGNEDNESS_UNSIGNED")]
	Unsigned,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcSignedness {
	type GlibType = ffi::ArvGcSignedness;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcSignedness {
		match self {
			Self::Undefined => ffi::ARV_GC_SIGNEDNESS_UNDEFINED,
			Self::Signed => ffi::ARV_GC_SIGNEDNESS_SIGNED,
			Self::Unsigned => ffi::ARV_GC_SIGNEDNESS_UNSIGNED,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcSignedness> for GcSignedness {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcSignedness) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_SIGNEDNESS_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_SIGNEDNESS_SIGNED => Self::Signed,
			ffi::ARV_GC_SIGNEDNESS_UNSIGNED => Self::Unsigned,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcSignedness {
	#[inline]
	#[doc(alias = "arv_gc_signedness_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_signedness_get_type()) }
	}
}

impl glib::HasParamSpec for GcSignedness {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcSignedness {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcSignedness {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcSignedness {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcSignedness> for glib::Value {
	#[inline]
	fn from(v: GcSignedness) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Denotes that the corresponding feature is prepared to be stored to and loaded from a file via the node tree.
/// The idea is to persist the state of a camera by storing the features marked as Streamable and restore the state by
/// writing those features back to the node tree.
#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcStreamable")]
pub enum GcStreamable {
	/// undefined streamable
	#[doc(alias = "ARV_GC_STREAMABLE_UNDEFINED")]
	Undefined,
	/// the feature can't be used for camera state persistence
	#[doc(alias = "ARV_GC_STREAMABLE_NO")]
	No,
	/// the feature can be used for camera state persistence
	#[doc(alias = "ARV_GC_STREAMABLE_YES")]
	Yes,
	#[doc(hidden)]
	__Unknown(i32),
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
#[doc(hidden)]
impl IntoGlib for GcStreamable {
	type GlibType = ffi::ArvGcStreamable;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcStreamable {
		match self {
			Self::Undefined => ffi::ARV_GC_STREAMABLE_UNDEFINED,
			Self::No => ffi::ARV_GC_STREAMABLE_NO,
			Self::Yes => ffi::ARV_GC_STREAMABLE_YES,
			Self::__Unknown(value) => value,
		}
	}
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
#[doc(hidden)]
impl FromGlib<ffi::ArvGcStreamable> for GcStreamable {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcStreamable) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_STREAMABLE_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_STREAMABLE_NO => Self::No,
			ffi::ARV_GC_STREAMABLE_YES => Self::Yes,
			value => Self::__Unknown(value),
		}
	}
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
impl StaticType for GcStreamable {
	#[inline]
	#[doc(alias = "arv_gc_streamable_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_streamable_get_type()) }
	}
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
impl glib::HasParamSpec for GcStreamable {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
impl glib::value::ValueType for GcStreamable {
	type Type = Self;
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
unsafe impl<'a> glib::value::FromValue<'a> for GcStreamable {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
impl ToValue for GcStreamable {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

#[cfg(feature = "v0_8_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
impl From<GcStreamable> for glib::Value {
	#[inline]
	fn from(v: GcStreamable) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Specifies feature node recommended visibility in user interfaces.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGcVisibility")]
pub enum GcVisibility {
	/// undefined feature visibility level
	#[doc(alias = "ARV_GC_VISIBILITY_UNDEFINED")]
	Undefined,
	/// feature should be not be visible in user interface
	#[doc(alias = "ARV_GC_VISIBILITY_INVISIBLE")]
	Invisible,
	/// very advanced feature to be shown to very experienced users
	#[doc(alias = "ARV_GC_VISIBILITY_GURU")]
	Guru,
	/// advanced feature to be shown to expert users
	#[doc(alias = "ARV_GC_VISIBILITY_EXPERT")]
	Expert,
	/// basic feature to be shown to all users
	#[doc(alias = "ARV_GC_VISIBILITY_BEGINNER")]
	Beginner,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GcVisibility {
	type GlibType = ffi::ArvGcVisibility;

	#[inline]
	fn into_glib(self) -> ffi::ArvGcVisibility {
		match self {
			Self::Undefined => ffi::ARV_GC_VISIBILITY_UNDEFINED,
			Self::Invisible => ffi::ARV_GC_VISIBILITY_INVISIBLE,
			Self::Guru => ffi::ARV_GC_VISIBILITY_GURU,
			Self::Expert => ffi::ARV_GC_VISIBILITY_EXPERT,
			Self::Beginner => ffi::ARV_GC_VISIBILITY_BEGINNER,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGcVisibility> for GcVisibility {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGcVisibility) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GC_VISIBILITY_UNDEFINED => Self::Undefined,
			ffi::ARV_GC_VISIBILITY_INVISIBLE => Self::Invisible,
			ffi::ARV_GC_VISIBILITY_GURU => Self::Guru,
			ffi::ARV_GC_VISIBILITY_EXPERT => Self::Expert,
			ffi::ARV_GC_VISIBILITY_BEGINNER => Self::Beginner,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GcVisibility {
	#[inline]
	#[doc(alias = "arv_gc_visibility_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gc_visibility_get_type()) }
	}
}

impl glib::HasParamSpec for GcVisibility {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GcVisibility {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GcVisibility {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GcVisibility {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GcVisibility> for glib::Value {
	#[inline]
	fn from(v: GcVisibility) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGvIpConfigurationMode")]
pub enum GvIpConfigurationMode {
	#[doc(alias = "ARV_GV_IP_CONFIGURATION_MODE_NONE")]
	None,
	#[doc(alias = "ARV_GV_IP_CONFIGURATION_MODE_PERSISTENT_IP")]
	PersistentIp,
	#[doc(alias = "ARV_GV_IP_CONFIGURATION_MODE_DHCP")]
	Dhcp,
	#[doc(alias = "ARV_GV_IP_CONFIGURATION_MODE_LLA")]
	Lla,
	#[doc(alias = "ARV_GV_IP_CONFIGURATION_MODE_FORCE_IP")]
	ForceIp,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GvIpConfigurationMode {
	type GlibType = ffi::ArvGvIpConfigurationMode;

	#[inline]
	fn into_glib(self) -> ffi::ArvGvIpConfigurationMode {
		match self {
			Self::None => ffi::ARV_GV_IP_CONFIGURATION_MODE_NONE,
			Self::PersistentIp => ffi::ARV_GV_IP_CONFIGURATION_MODE_PERSISTENT_IP,
			Self::Dhcp => ffi::ARV_GV_IP_CONFIGURATION_MODE_DHCP,
			Self::Lla => ffi::ARV_GV_IP_CONFIGURATION_MODE_LLA,
			Self::ForceIp => ffi::ARV_GV_IP_CONFIGURATION_MODE_FORCE_IP,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGvIpConfigurationMode> for GvIpConfigurationMode {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGvIpConfigurationMode) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GV_IP_CONFIGURATION_MODE_NONE => Self::None,
			ffi::ARV_GV_IP_CONFIGURATION_MODE_PERSISTENT_IP => Self::PersistentIp,
			ffi::ARV_GV_IP_CONFIGURATION_MODE_DHCP => Self::Dhcp,
			ffi::ARV_GV_IP_CONFIGURATION_MODE_LLA => Self::Lla,
			ffi::ARV_GV_IP_CONFIGURATION_MODE_FORCE_IP => Self::ForceIp,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GvIpConfigurationMode {
	#[inline]
	#[doc(alias = "arv_gv_ip_configuration_mode_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gv_ip_configuration_mode_get_type()) }
	}
}

impl glib::HasParamSpec for GvIpConfigurationMode {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GvIpConfigurationMode {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GvIpConfigurationMode {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GvIpConfigurationMode {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GvIpConfigurationMode> for glib::Value {
	#[inline]
	fn from(v: GvIpConfigurationMode) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGvPacketSizeAdjustment")]
pub enum GvPacketSizeAdjustment {
	/// never adjust packet size
	#[doc(alias = "ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER")]
	Never,
	/// adjust packet size if test packet check fails the with current
	/// packet size, only on the first stream creation
	#[doc(alias = "ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE")]
	OnFailureOnce,
	/// adjust packet size if test packet check fails with current packet size
	#[doc(alias = "ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE")]
	OnFailure,
	/// adjust packet size on the first stream creation
	#[doc(alias = "ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE")]
	Once,
	/// always adjust the stream packet size
	#[doc(alias = "ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS")]
	Always,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GvPacketSizeAdjustment {
	type GlibType = ffi::ArvGvPacketSizeAdjustment;

	#[inline]
	fn into_glib(self) -> ffi::ArvGvPacketSizeAdjustment {
		match self {
			Self::Never => ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER,
			Self::OnFailureOnce => ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE,
			Self::OnFailure => ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE,
			Self::Once => ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE,
			Self::Always => ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGvPacketSizeAdjustment> for GvPacketSizeAdjustment {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGvPacketSizeAdjustment) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_NEVER => Self::Never,
			ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE_ONCE => Self::OnFailureOnce,
			ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ON_FAILURE => Self::OnFailure,
			ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ONCE => Self::Once,
			ffi::ARV_GV_PACKET_SIZE_ADJUSTMENT_ALWAYS => Self::Always,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GvPacketSizeAdjustment {
	#[inline]
	#[doc(alias = "arv_gv_packet_size_adjustment_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gv_packet_size_adjustment_get_type()) }
	}
}

impl glib::HasParamSpec for GvPacketSizeAdjustment {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GvPacketSizeAdjustment {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GvPacketSizeAdjustment {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GvPacketSizeAdjustment {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GvPacketSizeAdjustment> for glib::Value {
	#[inline]
	fn from(v: GvPacketSizeAdjustment) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGvStreamPacketResend")]
pub enum GvStreamPacketResend {
	/// never request a packet resend
	#[doc(alias = "ARV_GV_STREAM_PACKET_RESEND_NEVER")]
	Never,
	/// request a packet resend if a packet was missing
	#[doc(alias = "ARV_GV_STREAM_PACKET_RESEND_ALWAYS")]
	Always,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GvStreamPacketResend {
	type GlibType = ffi::ArvGvStreamPacketResend;

	#[inline]
	fn into_glib(self) -> ffi::ArvGvStreamPacketResend {
		match self {
			Self::Never => ffi::ARV_GV_STREAM_PACKET_RESEND_NEVER,
			Self::Always => ffi::ARV_GV_STREAM_PACKET_RESEND_ALWAYS,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGvStreamPacketResend> for GvStreamPacketResend {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGvStreamPacketResend) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GV_STREAM_PACKET_RESEND_NEVER => Self::Never,
			ffi::ARV_GV_STREAM_PACKET_RESEND_ALWAYS => Self::Always,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamPacketResend {
	#[inline]
	#[doc(alias = "arv_gv_stream_packet_resend_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gv_stream_packet_resend_get_type()) }
	}
}

impl glib::HasParamSpec for GvStreamPacketResend {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GvStreamPacketResend {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GvStreamPacketResend {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GvStreamPacketResend {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GvStreamPacketResend> for glib::Value {
	#[inline]
	fn from(v: GvStreamPacketResend) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvGvStreamSocketBuffer")]
pub enum GvStreamSocketBuffer {
	/// socket buffer is set to a given fixed value
	#[doc(alias = "ARV_GV_STREAM_SOCKET_BUFFER_FIXED")]
	Fixed,
	/// socket buffer size is set to the payload size
	#[doc(alias = "ARV_GV_STREAM_SOCKET_BUFFER_AUTO")]
	Auto,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for GvStreamSocketBuffer {
	type GlibType = ffi::ArvGvStreamSocketBuffer;

	#[inline]
	fn into_glib(self) -> ffi::ArvGvStreamSocketBuffer {
		match self {
			Self::Fixed => ffi::ARV_GV_STREAM_SOCKET_BUFFER_FIXED,
			Self::Auto => ffi::ARV_GV_STREAM_SOCKET_BUFFER_AUTO,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvGvStreamSocketBuffer> for GvStreamSocketBuffer {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvGvStreamSocketBuffer) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_GV_STREAM_SOCKET_BUFFER_FIXED => Self::Fixed,
			ffi::ARV_GV_STREAM_SOCKET_BUFFER_AUTO => Self::Auto,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for GvStreamSocketBuffer {
	#[inline]
	#[doc(alias = "arv_gv_stream_socket_buffer_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_gv_stream_socket_buffer_get_type()) }
	}
}

impl glib::HasParamSpec for GvStreamSocketBuffer {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for GvStreamSocketBuffer {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GvStreamSocketBuffer {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for GvStreamSocketBuffer {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<GvStreamSocketBuffer> for glib::Value {
	#[inline]
	fn from(v: GvStreamSocketBuffer) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvRangeCheckPolicy")]
pub enum RangeCheckPolicy {
	/// never check if float or integer node value is in min/max range
	#[doc(alias = "ARV_RANGE_CHECK_POLICY_DISABLE")]
	Disable,
	/// always check if if float or integer node is in min/max range
	#[doc(alias = "ARV_RANGE_CHECK_POLICY_ENABLE")]
	Enable,
	/// check the value, but only display an error message if the value is not allowed (Since 0.8.8)
	#[doc(alias = "ARV_RANGE_CHECK_POLICY_DEBUG")]
	Debug,
	#[doc(hidden)]
	__Unknown(i32),
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
#[doc(hidden)]
impl IntoGlib for RangeCheckPolicy {
	type GlibType = ffi::ArvRangeCheckPolicy;

	#[inline]
	fn into_glib(self) -> ffi::ArvRangeCheckPolicy {
		match self {
			Self::Disable => ffi::ARV_RANGE_CHECK_POLICY_DISABLE,
			Self::Enable => ffi::ARV_RANGE_CHECK_POLICY_ENABLE,
			Self::Debug => ffi::ARV_RANGE_CHECK_POLICY_DEBUG,
			Self::__Unknown(value) => value,
		}
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
#[doc(hidden)]
impl FromGlib<ffi::ArvRangeCheckPolicy> for RangeCheckPolicy {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvRangeCheckPolicy) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_RANGE_CHECK_POLICY_DISABLE => Self::Disable,
			ffi::ARV_RANGE_CHECK_POLICY_ENABLE => Self::Enable,
			ffi::ARV_RANGE_CHECK_POLICY_DEBUG => Self::Debug,
			value => Self::__Unknown(value),
		}
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl StaticType for RangeCheckPolicy {
	#[inline]
	#[doc(alias = "arv_range_check_policy_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_range_check_policy_get_type()) }
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl glib::HasParamSpec for RangeCheckPolicy {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl glib::value::ValueType for RangeCheckPolicy {
	type Type = Self;
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
unsafe impl<'a> glib::value::FromValue<'a> for RangeCheckPolicy {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl ToValue for RangeCheckPolicy {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

#[cfg(feature = "v0_8_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_6")))]
impl From<RangeCheckPolicy> for glib::Value {
	#[inline]
	fn from(v: RangeCheckPolicy) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvRegisterCachePolicy")]
pub enum RegisterCachePolicy {
	/// disable register caching
	#[doc(alias = "ARV_REGISTER_CACHE_POLICY_DISABLE")]
	Disable,
	/// enable register caching
	#[doc(alias = "ARV_REGISTER_CACHE_POLICY_ENABLE")]
	Enable,
	/// enable register caching, but read the acual register value for comparison
	#[doc(alias = "ARV_REGISTER_CACHE_POLICY_DEBUG")]
	Debug,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RegisterCachePolicy {
	type GlibType = ffi::ArvRegisterCachePolicy;

	#[inline]
	fn into_glib(self) -> ffi::ArvRegisterCachePolicy {
		match self {
			Self::Disable => ffi::ARV_REGISTER_CACHE_POLICY_DISABLE,
			Self::Enable => ffi::ARV_REGISTER_CACHE_POLICY_ENABLE,
			Self::Debug => ffi::ARV_REGISTER_CACHE_POLICY_DEBUG,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvRegisterCachePolicy> for RegisterCachePolicy {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvRegisterCachePolicy) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_REGISTER_CACHE_POLICY_DISABLE => Self::Disable,
			ffi::ARV_REGISTER_CACHE_POLICY_ENABLE => Self::Enable,
			ffi::ARV_REGISTER_CACHE_POLICY_DEBUG => Self::Debug,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for RegisterCachePolicy {
	#[inline]
	#[doc(alias = "arv_register_cache_policy_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_register_cache_policy_get_type()) }
	}
}

impl glib::HasParamSpec for RegisterCachePolicy {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for RegisterCachePolicy {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RegisterCachePolicy {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for RegisterCachePolicy {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<RegisterCachePolicy> for glib::Value {
	#[inline]
	fn from(v: RegisterCachePolicy) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

/// Describes when the reason the stream callback is called. You are probably more interested in
/// [`Init`][Self::Init] and [`BufferDone`][Self::BufferDone].
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvStreamCallbackType")]
pub enum StreamCallbackType {
	/// thread initialization, happens once
	#[doc(alias = "ARV_STREAM_CALLBACK_TYPE_INIT")]
	Init,
	/// thread end, happens once
	#[doc(alias = "ARV_STREAM_CALLBACK_TYPE_EXIT")]
	Exit,
	/// buffer filling start, happens at each frame
	#[doc(alias = "ARV_STREAM_CALLBACK_TYPE_START_BUFFER")]
	StartBuffer,
	/// buffer filled, happens at each frame
	#[doc(alias = "ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE")]
	BufferDone,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for StreamCallbackType {
	type GlibType = ffi::ArvStreamCallbackType;

	#[inline]
	fn into_glib(self) -> ffi::ArvStreamCallbackType {
		match self {
			Self::Init => ffi::ARV_STREAM_CALLBACK_TYPE_INIT,
			Self::Exit => ffi::ARV_STREAM_CALLBACK_TYPE_EXIT,
			Self::StartBuffer => ffi::ARV_STREAM_CALLBACK_TYPE_START_BUFFER,
			Self::BufferDone => ffi::ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvStreamCallbackType> for StreamCallbackType {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvStreamCallbackType) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_STREAM_CALLBACK_TYPE_INIT => Self::Init,
			ffi::ARV_STREAM_CALLBACK_TYPE_EXIT => Self::Exit,
			ffi::ARV_STREAM_CALLBACK_TYPE_START_BUFFER => Self::StartBuffer,
			ffi::ARV_STREAM_CALLBACK_TYPE_BUFFER_DONE => Self::BufferDone,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for StreamCallbackType {
	#[inline]
	#[doc(alias = "arv_stream_callback_type_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_stream_callback_type_get_type()) }
	}
}

impl glib::HasParamSpec for StreamCallbackType {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for StreamCallbackType {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StreamCallbackType {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for StreamCallbackType {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<StreamCallbackType> for glib::Value {
	#[inline]
	fn from(v: StreamCallbackType) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvUvUsbMode")]
pub enum UvUsbMode {
	/// utilize libusb synchronous device I/O API
	#[doc(alias = "ARV_UV_USB_MODE_SYNC")]
	Sync,
	/// utilize libusb asynchronous device I/O API
	#[doc(alias = "ARV_UV_USB_MODE_ASYNC")]
	Async,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for UvUsbMode {
	type GlibType = ffi::ArvUvUsbMode;

	#[inline]
	fn into_glib(self) -> ffi::ArvUvUsbMode {
		match self {
			Self::Sync => ffi::ARV_UV_USB_MODE_SYNC,
			Self::Async => ffi::ARV_UV_USB_MODE_ASYNC,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvUvUsbMode> for UvUsbMode {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvUvUsbMode) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_UV_USB_MODE_SYNC => Self::Sync,
			ffi::ARV_UV_USB_MODE_ASYNC => Self::Async,
			value => Self::__Unknown(value),
		}
	}
}

impl StaticType for UvUsbMode {
	#[inline]
	#[doc(alias = "arv_uv_usb_mode_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_uv_usb_mode_get_type()) }
	}
}

impl glib::HasParamSpec for UvUsbMode {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for UvUsbMode {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for UvUsbMode {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for UvUsbMode {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<UvUsbMode> for glib::Value {
	#[inline]
	fn from(v: UvUsbMode) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ArvXmlSchemaError")]
pub enum XmlSchemaError {
	/// invalid structure
	#[doc(alias = "ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE")]
	Structure,
	#[doc(hidden)]
	__Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for XmlSchemaError {
	type GlibType = ffi::ArvXmlSchemaError;

	#[inline]
	fn into_glib(self) -> ffi::ArvXmlSchemaError {
		match self {
			Self::Structure => ffi::ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE,
			Self::__Unknown(value) => value,
		}
	}
}

#[doc(hidden)]
impl FromGlib<ffi::ArvXmlSchemaError> for XmlSchemaError {
	#[inline]
	unsafe fn from_glib(value: ffi::ArvXmlSchemaError) -> Self {
		skip_assert_initialized!();

		match value {
			ffi::ARV_XML_SCHEMA_ERROR_INVALID_STRUCTURE => Self::Structure,
			value => Self::__Unknown(value),
		}
	}
}

impl glib::error::ErrorDomain for XmlSchemaError {
	#[inline]
	fn domain() -> glib::Quark {
		skip_assert_initialized!();

		unsafe { from_glib(ffi::arv_xml_schema_error_quark()) }
	}

	#[inline]
	fn code(self) -> i32 {
		self.into_glib()
	}

	#[inline]
	#[allow(clippy::match_single_binding)]
	fn from(code: i32) -> Option<Self> {
		skip_assert_initialized!();
		match unsafe { from_glib(code) } {
			value => Some(value),
		}
	}
}

impl StaticType for XmlSchemaError {
	#[inline]
	#[doc(alias = "arv_xml_schema_error_get_type")]
	fn static_type() -> glib::Type {
		unsafe { from_glib(ffi::arv_xml_schema_error_get_type()) }
	}
}

impl glib::HasParamSpec for XmlSchemaError {
	type ParamSpec = glib::ParamSpecEnum;
	type SetValue = Self;
	type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

	fn param_spec_builder() -> Self::BuilderFn {
		Self::ParamSpec::builder_with_default
	}
}

impl glib::value::ValueType for XmlSchemaError {
	type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for XmlSchemaError {
	type Checker = glib::value::GenericValueTypeChecker<Self>;

	#[inline]
	unsafe fn from_value(value: &'a glib::Value) -> Self {
		skip_assert_initialized!();
		from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
	}
}

impl ToValue for XmlSchemaError {
	#[inline]
	fn to_value(&self) -> glib::Value {
		let mut value = glib::Value::for_value_type::<Self>();
		unsafe {
			glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
		}
		value
	}

	#[inline]
	fn value_type(&self) -> glib::Type {
		Self::static_type()
	}
}

impl From<XmlSchemaError> for glib::Value {
	#[inline]
	fn from(v: XmlSchemaError) -> Self {
		skip_assert_initialized!();
		ToValue::to_value(&v)
	}
}
